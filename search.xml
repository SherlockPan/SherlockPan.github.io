<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[差分约束例题]]></title>
    <url>%2F2018%2F05%2F25%2F%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%2F</url>
    <content type="text"><![CDATA[前言这几天刷 bzoj 的题，碰到几道差分约束的…想到博客里还没有这类题目（图论也没有…所以来填一下这方面的空缺 侵删 简述差分约束我们来看一下这个看样子很高大上的东西其实这玩意就是跑最短路的我觉得最短路不需要进行讲解基本知识嘛所以我们直接看差分约束的精髓 如果一个系统由 n 个元素 m 个不等式组成，并且每个不等式都是类似于 a - b &gt; c 的（意思就是说长成这样的），把这个不等式移项，我们可以得到 a &gt; b + c ，这表示什么意思呢？我们把 a , b 都看成一个点，如果满足这条不等式，不就代表 b 到 a 的有向边权值大于 c 吗（同大于等于，小于，小于等于，等于），我们也可以说成 a 到 b 有一条权值小于 -c 的边 因此我们发现，对于每个不等式（只有两个元素），类似于 a[i]-a[j]&lt;=c ,我们可以认为对于节点 j 和 i 建立一条 j -&gt; i 的有向边，且边权为 c 。而如果我们要求点 i 的最短路，即求 a[i] 到 a[0] 的最大值 我们来看一组不等式 x1 - x0 &lt;=2 (1) x2 - x0 &lt;=7 (2) x3 - x0 &lt;=8 (3) x2 - x1 &lt;=3 (4) x3 - x2 &lt;=2 (5) 我们先整理出一些数与数关系 (3) ： x3 - x0 &lt;= 8 (2) + (5) ： x3 - x0 &lt;= 9 (1) + (4) + (5) ： x3 - x2 &lt;= 7 所以我们最终可以得到 x3 - x0 &lt;= 7 先把上面内容放在一旁，我们来看一道求最短路的题: 给定四个小岛以及小岛之间的有向距离，问从第0个岛到第3个岛的最短距离。箭头表示有向边，蓝色数字表示权值（画的丑勿介 好了我们有一张很好的图…这是一道很简单的最短路问题，我们枚举路线，一共有三条 0 -&gt; 3 长度为 8 0 -&gt; 2 -&gt; 3 长度为 7 + 2 = 9 0 -&gt; 1 -&gt; 2 -&gt; 3 长度为 2 + 3 + 2 = 7 所以 x0 到 x3 的距离最小为 7 ，是不是觉得跟上面的不等式有什么关系？我们结合求单源最短路的方法（ spfa ，Dijkstra ）很容易发现我们一开始讲的差分约束就是一种数形结合的例子，对于每一个不等式，我们都可以相应的建立一条有向边，上面举例的不等式和图就是可以互相转化的（没毛病吧？！实际上我们接触很频繁的三角不等式，对应的建图 很容易就可以知道 min ( b , a+c ),正好对应 a —&gt; c 的最短路。我们将三个不等式推广到 m 个，变量从 3 个推广到 n 个，就变成 n 个点 m 条边的最短路了 我们现在来看一下解的存在性 我们求一条最短路，在图中可能会存在负环或者到终点不存在连边 因此对应负环，在图中一定是不存在最短路的，这种情况是无解的 如果我们连不到终点，表示起点和终点并没有约束关系，因此这种情况的结果是无限多个解 在实际问题中我们要加以判断，可能会导致不同的输出 综上所述，一个差分约束系统我们有三种解：有解，无解，有无限多解 现在我们来看一下别的不等式情况 如果我们将原先的 &lt;= 变成 &gt;= ，我们求两点之间之差的最小值，求的是两点之间的最长路（数形结合）我们同样可以从三角不等式进行推广 如果给出的不等式有”&lt;=”也有”&gt;=”，又该如何解决呢？很明显，首先需要关注最后的问题是什么，如果需要求的是两个变量差的最大值，那么需要将所有不等式转变成”&lt;=”的形式，建图后求最短路；相反，如果需要求的是两个变量差的最小值，那么需要将所有不等式转化成”&gt;=”，建图后求最长路。 如果存在类似于 a - b = c 的不等式，我们可以转化成 a - b &gt;= c 或者 a - b &lt;= c，再根据实际情况进行建边 另外，如果这些变量都是整数，在遇到形如 a - b &gt; c 的情况，我们不能用小于号建边（因为不等），我们要把它们转变成带等号的不等式，比如 a - b &gt;= c+1 我尽量保持原创，图也是自己画的差分约束其实很简单说是简述我也写了很多…所以我们现在来看两道题目 SCOI2011 糖果题目描述幼儿园里有N个小朋友，lxhgww老师现在想要给这些小朋友们分配糖果，要求每个小朋友都要分到糖果。但是小朋友们也有嫉妒心，总是会提出一些要求，比如小明不希望小红分到的糖果比他的多，于是在分配糖果的时候，lxhgww需要满足小朋友们的K个要求。幼儿园的糖果总是有限的，lxhgww想知道他至少需要准备多少个糖果，才能使得每个小朋友都能够分到糖果，并且满足小朋友们所有的要求。 输入输出格式输入格式：输入的第一行是两个整数N，K。接下来K行，表示这些点需要满足的关系，每行3个数字，X，A，B。如果X=1， 表示第A个小朋友分到的糖果必须和第B个小朋友分到的糖果一样多；如果X=2， 表示第A个小朋友分到的糖果必须少于第B个小朋友分到的糖果；如果X=3， 表示第A个小朋友分到的糖果必须不少于第B个小朋友分到的糖果；如果X=4， 表示第A个小朋友分到的糖果必须多于第B个小朋友分到的糖果；如果X=5， 表示第A个小朋友分到的糖果必须不多于第B个小朋友分到的糖果； 输出格式：输出一行，表示lxhgww老师至少需要准备的糖果数，如果不能满足小朋友们的所有要求，就输出-1。 输入输出样例#####输入样例#1： 5 7 1 1 2 2 3 2 4 4 1 3 4 5 5 4 5 2 3 5 4 5 1 #####输出样例#1： 11 说明【数据范围】 对于30%的数据，保证 N&lt;=100 对于100%的数据，保证 N&lt;=100000 对于所有的数据，保证 K&lt;=100000，1&lt;=X&lt;=5，1&lt;=A, B&lt;=N 解题分析我们发现这道题有很多不等式…看到不等式我就想到了差分约束不过这道题的约束条件很多，我们要区分好，不能在建边的时候弄混used用来判断负环因为一个点不可能被经过超过 n 次实际上 spfa 是从 0 开始跑的我直接进队列也是一样的…可能我建边跟网上很多题解不一样反过来也是一样的对于每次读入情况第二种和第四种 a == b 是要进行特判的另外不能忘记判负环的情况计算答案的时候 long long 要开不然会 WA注意空间开大一点建议用 BZOJ 跑洛谷数据太水了相同代码BZOJ RE90分洛谷AC…交代就那么多有什么东西代码里看好了，就是一个 spfa 要小心 AC代码96ms123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// luogu-judger-enable-o2#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;cctype&gt;#define re register int#define xep(i,x) for(re i=head[x];i;i=nxt[i])#define ll long longusing namespace std;const int N=100010;int n,k,cnt=0;int head[N&lt;&lt;2],nxt[N&lt;&lt;2],to[N&lt;&lt;2],val[N&lt;&lt;2];int vis[N],sum[N],used[N];ll ans=0;queue &lt; int &gt; q;inline int read()&#123; int X=0,w=0; char ch=0; while(!isdigit(ch)) &#123;w|=ch=='-';ch=getchar();&#125; while(isdigit(ch)) X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void add(int x,int y,int v)&#123; to[++cnt]=y;nxt[cnt]=head[x]; head[x]=cnt;val[cnt]=v;&#125;inline bool spfa()&#123; while(!q.empty())&#123; int u=q.front(); vis[u]=0;q.pop(); xep(i,u)&#123; int v=to[i]; if(sum[v]&lt;sum[u]+val[i])&#123; sum[v]=sum[u]+val[i]; used[v]++; if(used[v]&gt;n) return 0; if(!vis[v]) vis[v]=1,q.push(v); &#125; &#125; &#125; return 1;&#125;int main()&#123; n=read();k=read(); while(k--)&#123; int opt,a,b; scanf("%d%d%d",&amp;opt,&amp;a,&amp;b); switch(opt)&#123; case 1:&#123;add(a,b,0);add(b,a,0);break;&#125; case 2:&#123; if(a==b)&#123; puts("-1");return 0; &#125; add(a,b,1);break; &#125; case 3:&#123;add(b,a,0);break;&#125; case 4:&#123; if(a==b)&#123; puts("-1"); return 0; &#125; add(b,a,1);break; &#125; case 5:&#123;add(a,b,0);break;&#125; &#125; &#125; for(re i=1;i&lt;=n;i++) vis[i]=1,sum[i]=1,q.push(i); if(!spfa())&#123; puts("-1");return 0; &#125; for(re i=1;i&lt;=n;i++) ans+=sum[i]; printf("%lld\n",ans); return 0;&#125; BZOJ3436 小K的农场题目描述小K在MC里面建立很多很多的农场，总共n个，以至于他自己都忘记了每个农场中种植作物的具体数量了，他只记得一些含糊的信息（共m个），以下列三种形式描述：农场a比农场b至少多种植了c个单位的作物，农场a比农场b至多多种植了c个单位的作物，农场a与农场b种植的作物数一样多。但是，由于小K的记忆有些偏差，所以他想要知道存不存在一种情况，使得农场的种植作物数量与他记忆中的所有信息吻合。 输入输出格式输入格式：第一行包括两个整数 n 和 m，分别表示农场数目和小 K 记忆中的信息数目。接下来 m 行：如果每行的第一个数是 1，接下来有 3 个整数 a,b,c，表示农场 a 比农场 b 至少多种植了 c 个单位的作物。如果每行的第一个数是 2，接下来有 3 个整数 a,b,c，表示农场 a 比农场 b 至多多种植了 c 个单位的作物。如果每行的第一个数是 3，家下来有 2 个整数 a,b，表示农场 a 终止的数量和 b 一样多。 输出格式：如果存在某种情况与小 K 的记忆吻合，输出“Yes”，否则输出“No”。 输入输出样例输入样例#1：3 3 3 1 2 1 1 3 1 2 2 3 2 输出样例#1：Yes 说明对于 100% 的数据保证：1 ≤ n，m，a，b，c ≤ 10000。 解题思路这道题跟上一道很像只要搞清楚约束条件，对于一般的差分约束题目还是蛮好解的相较之下这道题还比较简单，只需要判一下 spfa 是否为真，并不像上一道题一样要统计答案但是同样洛谷AC大视野RE debug了好久还是洛谷数据水…实际上就是判负环的时候在 if 里面判…还是直接上代码好了挺简单的（我的建边还是和别人不一样… AC代码2264ms12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// luogu-judger-enable-o2#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;cctype&gt;#define re register int#define xep(i,x) for(re i=head[x];i;i=nxt[i]) using namespace std;inline int read()&#123; int X=0,w=0; char ch=0; while(!isdigit(ch)) &#123;w|=ch=='-';ch=getchar();&#125; while(isdigit(ch)) X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;const int N=10010;int n,m,cnt=0;int head[N&lt;&lt;2],nxt[N&lt;&lt;2],to[N&lt;&lt;2],val[N&lt;&lt;2];int sum[N],vis[N],ru[N];queue &lt; int &gt; q;inline void add(int x,int y,int v)&#123; to[++cnt]=y;nxt[cnt]=head[x]; head[x]=cnt;val[cnt]=v;&#125;inline bool spfa()&#123; while(!q.empty())&#123; int u=q.front();q.pop(); vis[u]=0; xep(i,u)&#123; int v=to[i]; if(sum[v]&lt;sum[u]+val[i])&#123; sum[v]=sum[u]+val[i]; ru[i]++; if(ru[i]&gt;n) return 0; if(!vis[v]) vis[v]=1,q.push(v); &#125; &#125; &#125; return 1;&#125;int main()&#123; memset(sum,0,sizeof(sum)); n=read();m=read(); for(re i=1;i&lt;=m;i++)&#123; int opt,a,b,c; opt=read();a=read();b=read(); if(opt==1) c=read(),add(b,a,c); else if(opt==2) c=read(),add(a,b,-c); else if(opt==3) add(a,b,0),add(b,a,0); &#125; for(re i=1;i&lt;=n;i++) vis[i]=1,q.push(i); spfa()?puts("Yes"):puts("No"); return 0;&#125; 后记看到很多不等式就要想到差分约束…想到差分约束转化一下不等式建边还是很容易的建完边跑最短路或最长路不就很简单了？所以上面三句话就是差分约束的精髓（滑稽这东西还是蛮基础也是挺有用的写了一个多小时也是挺久的手打很累…也就是因为下午做到了两道模板的差分约束 欢迎指正联系方式如下… qq： 953559040 微博： IncinblePan 洛谷： SherlockPan]]></content>
  </entry>
  <entry>
    <title><![CDATA[SDOI2011 染色]]></title>
    <url>%2F2018%2F05%2F23%2Fsdoi2011%2F</url>
    <content type="text"><![CDATA[前言本来想找一道树剖的题的发现LCT可做… 侵删（博客习惯… 题目我们来看一道正解为树剖的题目… 题目描述给定一棵有n个节点的无根树和m个操作，操作有2类：1、将节点a到节点b路径上所有点都染成颜色c；2、询问节点a到节点b路径上的颜色段数量（连续相同颜色被认为是同一段），如“112221”由3段组成：“11”、“222”和“1”。请你写一个程序依次完成这m个操作。 输入第一行包含2个整数n和m，分别表示节点数和操作数；第二行包含n个正整数表示n个节点的初始颜色下面 行每行包含两个整数x和y，表示x和y之间有一条无向边。下面 行每行描述一个操作：“C a b c”表示这是一个染色操作，把节点a到节点b路径上所有点（包括a和b）都染成颜色c；“Q a b”表示这是一个询问操作，询问节点a到节点b（包括a和b）路径上的颜色段数量。 输出对于每个询问操作，输出一行答案。 样例输入6 5 2 2 1 2 1 1 1 2 1 3 2 4 2 5 2 6 Q 3 5 C 2 1 1 Q 3 5 C 5 1 2 Q 3 5 样例输出3 1 2 提示数 N&lt;=105，操作数 M &lt;= 105，所有的颜色C为整数且在[ 0 , 109 ]之间。 解题树链剖分正解是树剖… 树链剖分解题思路一道很接近板子的树剖加上记录一条线段最左边的颜色和最右边的颜色进行维护 sum 值的时候判断颜色是否相同…树链剖分虽然代码很长但是跑的比较快的…是时候展现一波一百六十多行的代码 树链剖分AC代码2008ms123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; using namespace std; const int N=100+50; const int MAXN=100000+50; #define L(x) (x&lt;&lt;1) #define R(x) (x&lt;&lt;1|1) int n,m,cnt1,cnt,Lc,Rc; char str[N]; int col[MAXN],head[MAXN],sz[MAXN],dep[MAXN],fa[MAXN],son[MAXN],top[MAXN],pos[MAXN]; struct Edge&#123; int u,v,next; &#125;edge[MAXN&lt;&lt;1]; struct node&#123; int l,r; int num,tag,lc,rc; &#125;Tree[MAXN&lt;&lt;2]; void init()&#123; cnt1=cnt=0; memset(head,-1,sizeof(head)); &#125; void add(int u,int v)&#123; edge[cnt1].u=u; edge[cnt1].v=v; edge[cnt1].next=head[u]; head[u]=cnt1++; &#125; void dfs1(int u,int pre,int depth)&#123; sz[u]=1; fa[u]=pre; son[u]=0; dep[u]=depth; for(int i=head[u];i!=-1;i=edge[i].next)&#123; int v=edge[i].v; if(v==pre) continue; dfs1(v,u,depth+1); sz[u]+=sz[v]; if(sz[son[u]]&lt;sz[v]) son[u]=v; &#125; &#125; void dfs2(int u,int tp)&#123; pos[u]=++cnt;top[u]=tp; if(son[u]!=0) dfs2(son[u],top[u]); for(int i=head[u];i!=-1;i=edge[i].next)&#123; int v=edge[i].v; if(v==fa[u]||v==son[u]) continue; dfs2(v,v); &#125; &#125; void push_down(int rt)&#123; if(Tree[rt].tag)&#123; Tree[L(rt)].tag=Tree[R(rt)].tag=Tree[rt].tag; Tree[L(rt)].num=Tree[R(rt)].num=1; Tree[L(rt)].lc=Tree[L(rt)].rc=Tree[rt].lc; Tree[R(rt)].lc=Tree[R(rt)].rc=Tree[rt].lc; Tree[rt].tag=0; &#125; &#125; void push_up(int rt)&#123; Tree[rt].lc=Tree[L(rt)].lc; Tree[rt].rc=Tree[R(rt)].rc; int ans=Tree[L(rt)].num+Tree[R(rt)].num; if(Tree[L(rt)].rc==Tree[R(rt)].lc) ans--; Tree[rt].num=ans; &#125; void build(int rt,int l,int r)&#123; Tree[rt].l=l;Tree[rt].r=r;Tree[rt].num=0; if(l==r) return; int mid=(l+r)&gt;&gt;1; build(L(rt),l,mid);build(R(rt),mid+1,r); &#125; void update(int rt,int l,int r,int x)&#123; if(Tree[rt].l==l&amp;&amp;Tree[rt].r==r)&#123; Tree[rt].num=Tree[rt].tag=1; Tree[rt].lc=Tree[rt].rc=x; return; &#125; push_down(rt); int mid=(Tree[rt].l+Tree[rt].r)&gt;&gt;1; if(r&lt;=mid) update(L(rt),l,r,x); else if(l&gt;mid) update(R(rt),l,r,x); else update(L(rt),l,mid,x),update(R(rt),mid+1,r,x); push_up(rt);&#125; int query(int rt,int l,int r,int L,int R)&#123; if(Tree[rt].l==L) Lc=Tree[rt].lc; if(Tree[rt].r==R) Rc=Tree[rt].rc; if(Tree[rt].l==l&amp;&amp;Tree[rt].r==r) return Tree[rt].num; push_down(rt); int mid=(Tree[rt].l+Tree[rt].r)&gt;&gt;1; if(r&lt;=mid) return query(L(rt),l,r,L,R); else if(l&gt;mid) return query(R(rt),l,r,L,R); else&#123; int ans=query(L(rt),l,mid,L,R)+query(R(rt),mid+1,r,L,R); if(Tree[L(rt)].rc==Tree[R(rt)].lc) ans--; return ans; &#125; push_up(rt);&#125;int solve(int u,int v,int id,int c)&#123; int ans=0; if(id==1)&#123; while(top[u]!=top[v])&#123; if(dep[top[u]]&lt;dep[top[v]]) swap(u,v); update(1,pos[top[u]],pos[u],c); u=fa[top[u]]; &#125; if(dep[u]&gt;dep[v]) swap(u,v); update(1,pos[u],pos[v],c); &#125; else&#123; int ans1=-1,ans2=-1; while(top[u]!=top[v])&#123; if(dep[top[u]]&lt;dep[top[v]])&#123; swap(u,v);swap(ans1,ans2); &#125; ans+=query(1,pos[top[u]],pos[u],pos[top[u]],pos[u]); if(Rc==ans1) ans--; ans1=Lc;u=fa[top[u]]; &#125; if(dep[u]&lt;dep[v])&#123; swap(u,v);swap(ans1,ans2); &#125; ans+=query(1,pos[v],pos[u],pos[v],pos[u]); if(Rc==ans1) ans--; if(Lc==ans2) ans--; &#125; return ans; &#125; int main()&#123; while(~scanf("%d%d",&amp;n,&amp;m))&#123; init(); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;col[i]); for(int i=1;i&lt;n;i++)&#123; int u,v; scanf("%d%d",&amp;u,&amp;v); add(u,v);add(v,u); &#125; dfs1(1,1,1);dfs2(1,1);build(1,1,n); for(int i=1;i&lt;=n;i++) update(1,pos[i],pos[i],col[i]); while(m--)&#123; scanf("%s",str); int u,v; if(str[0] == 'C')&#123; int c; scanf("%d%d%d",&amp;u,&amp;v,&amp;c); solve(u,v,1,c); &#125; else&#123; int u,v; scanf("%d%d",&amp;u,&amp;v); printf("%d\n",solve(u,v,2,0)); &#125; &#125; &#125; return 0; &#125; 又难打又难修… LCT乍一看LCT也能写？！ LCT解题思路一道很接近模板的LCT，我觉得这道题用来练LCT也是不错的比一般的模板多出了几个元素需要我们去维护基本操作是差不多的而且还少了 cut 操作，但是 push_down 与 update 的写法也不太一样需要我们去想总的来说，我们需要判断一个节点的左儿子最右边的颜色和右儿子最左边的颜色是不是和这个节点相同所以我们多出的元素就是一条链最左边的颜色和最右边的颜色需要记录最初的赋值也是要注意的，这次的标记我们不再使用一个而是需要两个了另外区间翻转的时候不能只翻转左儿子和右儿子，记录的最左边的颜色和最右边的颜色也是需要翻转的关于上面的判断我觉得代码还是很需要想的毕竟不是那么容易就能实现的还有一件事我不知道为什么在 link 里把 find（x）==find（y）去掉我就AC否则RE相较之下LCT代码量虽短但是需要想的东西很多细节也很多代码不容易打好而树剖就比较无脑了…我开始就以为无脑打LCT就没仔细想 push_down 和 update所以我们来看一下一百行的LCT…有什么不会就在代码里找吧 LCT AC代码4740ms123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103// luogu-judger-enable-o2#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#define re register int#define rep(i,a,b) for(re i=(a);i&lt;=(b);++(i))#define drep(i,a,b) for(re i=(a);i&gt;=(b);--(i))using namespace std;inline int read()&#123; int X=0,w=0; char ch=0; while(!isdigit(ch)) &#123;w|=ch=='-';ch=getchar();&#125; while(isdigit(ch)) X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;const int N=100010;int n,m,x,y,z;char opt;struct LCT&#123; int a[N],fa[N],ch[N][2],lc[N],rc[N],sum[N],tag[N],rev[N],stk[N],top; inline bool isroot(int x)&#123;return ch[fa[x]][0]!=x&amp;&amp;ch[fa[x]][1]!=x;&#125; inline void push_down(int x)&#123; if(tag[x])&#123; tag[ch[x][0]]^=1;tag[ch[x][1]]^=1; swap(ch[x][0],ch[x][1]);tag[x]=0; swap(lc[ch[x][0]],rc[ch[x][0]]); swap(lc[ch[x][1]],rc[ch[x][1]]); &#125; if(rev[x])&#123; lc[x]=rc[x]=a[x]=rev[x]; rev[ch[x][0]]=rev[ch[x][1]]=rev[x]; sum[x]=rev[x]=0; &#125; &#125; inline void update(int x)&#123; push_down(ch[x][0]);push_down(ch[x][1]); sum[x]=sum[ch[x][0]]+sum[ch[x][1]]; if(ch[x][0])&#123; lc[x]=lc[ch[x][0]]; if(a[x]!=rc[ch[x][0]]) sum[x]++; &#125; else lc[x]=a[x]; if(ch[x][1])&#123; rc[x]=rc[ch[x][1]]; if(a[x]!=lc[ch[x][1]]) sum[x]++; &#125; else rc[x]=a[x]; &#125; inline void rotate(int x)&#123; re y=fa[x],z=fa[y],k=ch[y][1]==x; if(!isroot(y)) ch[z][ch[z][1]==y]=x; fa[x]=z;fa[ch[x][k^1]]=y;ch[y][k]=ch[x][k^1]; fa[y]=x;ch[x][k^1]=y;update(y); &#125; inline void splay(int x)&#123; stk[top=1]=x;for(int i=x;!isroot(i);i=fa[i]) stk[++top]=fa[i]; drep(i,top,1) push_down(stk[i]); for(re y=fa[x],z=fa[y];!isroot(x);y=fa[x],z=fa[y])&#123; if(!isroot(y)) ((ch[y][0]==x)^(ch[z][0]==y))?rotate(x):rotate(y); rotate(x); &#125;update(x); &#125; inline int access(int x)&#123; int t=0; while(x)&#123; splay(x);ch[x][1]=t;t=x;update(x);x=fa[x]; &#125; return t; &#125; inline void makeroot(int x)&#123; access(x);splay(x);tag[x]^=1; &#125; inline void link(int x,int y)&#123; makeroot(x);fa[x]=y; &#125;&#125;lct;int main()&#123; scanf("%d%d",&amp;n,&amp;m); rep(i,1,n) scanf("%d",&amp;lct.a[i]),lct.lc[i]=lct.rc[i]=lct.a[i]; rep(i,1,n-1) &#123; scanf("%d%d",&amp;x,&amp;y); lct.link(x,y); &#125; while(m--)&#123; opt=getchar(); while(opt!='C'&amp;&amp;opt!='Q') opt=getchar(); if(opt=='C')&#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); lct.makeroot(x),lct.access(y);lct.splay(y); lct.rev[y]=z; &#125; if(opt=='Q')&#123; scanf("%d%d",&amp;x,&amp;y); lct.makeroot(x);lct.access(y);lct.splay(y); printf("%d\n",lct.sum[y]+1); &#125; &#125; return 0;&#125; 后记事实证明，树剖代码量很大…（接近5K…但是树剖跑的比LCT快…（2008ms与4740ms但是我树剖修了好久（代码量太大不容易debug…一定是我太菜了虽然deLCT的时候也有一些不明不白的锅…欢迎指正…联系方式如下 qq： 953559040 微博： IncinblePan 洛谷： SherlockPan]]></content>
  </entry>
  <entry>
    <title><![CDATA[树链剖分浅析]]></title>
    <url>%2F2018%2F05%2F22%2F%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%2F</url>
    <content type="text"><![CDATA[前言前几天看了树剖有点忘了… mmp树剖的元素太多了我还是用 lct 好了…侵删 树链剖分引言树链剖分，顾名思义，就是把一棵树分割成很多条链在实际操作中，我们经常需要把一棵树剖分成很多条链，如果要进行查询或修改路径，用线段树维护那么我们如何实现呢？ 剖分与线段树结合树链剖分离不开剖分操作，而剖分操作是靠 dfs 完成的 我们先来看一下概念 重儿子：节点 i 的儿子节点中拥有子节点最多的点 轻儿子：节点 i 除去重儿子的其他儿子节点 重边：节点 i 与它的重儿子连成的边 轻边：节点 i 与它的轻儿子连成的边 重链：由重边连成的路径 轻链：由轻边连成的路径 一个点只有一个重儿子注意儿子节点和子节点概念不同 还有以下我们设置一些数组的表示 size（ i ）表示根为 i 的点的子节点数目 son （ i ）表示节点 i 的儿子节点中 size 最大的点 dep ( i ) 表示节点 i 的深度（一棵树总是有深度 fa ( i ) 表示节点 i 的父亲节点 top （ i ）表示的是节点 i 所在链的顶端（在求LCA问题中用处很大 树剖就是把一棵树剖分成重链和轻链，来看这样一棵树 照以上的描述，标记为黑色粗边的为重链，每一条黑色粗边为重边标记为红色的点为每一条链的 top ，细边的为轻链 以上是剖分的基本概念，如果要和线段树相结合，我们用 id（ i ） 表示点 i 与 fa ( i ) 的连边在线段树上的编号 wt（ i ） 表示这条连边的值 再次参考上面的图，每条边旁边的数字就是该边在线段树上的编号 那为什么我们要用线段树呢 线段树可以在 log 的级别询问修改区间，但是如果我们要在一棵树上进行路径的询问和修改，那么只凭线段树是不可行的，所以我们要在树上先进行树链剖分，然后能够满足线段树的操作总的来说在树剖里用线段树，线段树的写法和一般的线段树是差不多的…我们维护的是拆分后的树链，对于一棵树的询问修改就变成了 log 级别的了 算法实现我们先用一次 dfs 来求出各个点的 siz , fa , dep , son这个实现其实很简单 1234567891011inline void dfs1(int x,int f,int deep)&#123; dep[x]=deep;fa[x]=f;siz[x]=1; int maxson=-1; for(Rint i=beg[x];i;i=nex[i])&#123; int y=to[i]; if(y==f)continue; dfs1(y,x,deep+1); siz[x]+=siz[y]; if(siz[y]&gt;maxson)son[x]=y,maxson=siz[y]; &#125;&#125; 我们用再做一次 dfs 来进行 id ，wt ， top 的赋值 12345678910inline void dfs2(int x,int topf)&#123; id[x]=++cnt;wt[cnt]=w[x];top[x]=topf; if(!son[x])return; dfs2(son[x],topf); for(Rint i=beg[x];i;i=nex[i])&#123; int y=to[i]; if(y==fa[x]||y==son[x])continue; dfs2(y,y); &#125;&#125; 讲述也比较麻烦就直接看代码了也是很好理解的 树剖解LCA问题现在我们先来看一下用树剖解LCA问题 询问两个点 x ,y ，我们要求他们的公共祖先。对于每一条树链我们已经求出了这一条树链中深度最小的点，那么如果 top ( x )==top （ y ） ，那么 x 和 y 的最近公共祖先就是 min（ x , y ）如果 top（ x ）! = top ( y ) ，我们就往上找祖先，取 top（ x ） , top ( y ) 的最小值min，再判断 top ( fa ( min ) )与另一个点的 top 是不是相等，一直这样做，直到两点的 top 相等即可我们来看一下代码实现 12345while(top[x]!=top[y])&#123; if(dep[top[x]]&gt;=dep[top[y]]) x=fa[top[x]]; else y=fa[top[y]];&#125;printf("%d\n",dep[x]&lt;dep[y]?x:y); 在题目中应用，时间跑的应该不是很慢的，还是比较优越的… 树链在线段树中的维护我们再来看一下树剖后在线段树中的应用 我们将树的各边的权值在线段树中维护更新 如果我们要进行修改操作，比如将 u 与 v 路径上的每条边的权值都加上 c ，我们可以求出 u 到 v 的 lca,然后慢慢修改 u , v 到公共祖先的边但是我们有更加优越的算法记f1 = top（u），f2 = top(v)。当 f1 != f2 时：不妨设 dep(f1) &gt;= dep(f2)，那么就更新 u 到 f1 的父边的权值(logn)，并使 u = fa(f1)当 f1 == f2 时：u 与 v 在同一条重链上，若 u 与 v 不是同一点，就更新 u 到 v 路径上的边的权值(logn)，否则修改完成重复上述操作直至完成在进行求和的操作时，类似修改操作，但是不更新边权 我们依旧用那张图进行演示 当要修改11到10的路径时。第一次迭代：u = 11，v = 10，f1 = 2，f2 = 10。此时 dep（f1） &lt; dep（f2），因此修改线段树中的5号点，v = 4, f2 = 1；第二次迭代：dep（f1） &gt; dep（f2），修改线段树中10–11号点。u = 2，f1 = 2；第三次迭代：dep（f1） &gt; dep（f2），修改线段树中9号点。u = 1，f1 = 1；第四次迭代：f1 = f2 且 u = v，修改结束。 （其实我自己是不会画图的…逃 我们来看一下模板题 题目题目描述如题，已知一棵包含N个结点的树（连通且无环），每个节点上包含一个数值，需要支持以下操作： 操作1： 格式： 1 x y z 表示将树从x到y结点最短路径上所有节点的值都加上z 操作2： 格式： 2 x y 表示求树从x到y结点最短路径上所有节点的值之和 操作3： 格式： 3 x z 表示将以x为根节点的子树内所有节点值都加上z 操作4： 格式： 4 x 表示求以x为根节点的子树内所有节点值之和 输入输出格式输入格式：第一行包含4个正整数N、M、R、P，分别表示树的结点个数、操作个数、根节点序号和取模数（即所有的输出结果均对此取模）。 接下来一行包含N个非负整数，分别依次表示各个节点上初始的数值。 接下来N-1行每行包含两个整数x、y，表示点x和点y之间连有一条边（保证无环且连通） 接下来M行每行包含若干个正整数，每行表示一个操作，格式如下： 操作1： 1 x y z 操作2： 2 x y 操作3： 3 x z 操作4： 4 x 输出格式：输出包含若干行，分别依次表示每个操作2或操作4所得的结果（对P取模） 输入输出样例输入样例#1：5 5 2 24 7 3 7 8 0 1 2 1 5 3 1 4 1 3 4 2 3 2 2 4 5 1 5 1 3 2 1 3 输出样例#1：2 21 说明时空限制：1s，128M 数据规模：对于30%的数据： N ≤ 10, M ≤ 10 对于70%的数据： N ≤ 103, M ≤ 103 对于100%的数据： N≤10 5 , M ≤ 105 解题思路树剖后套上线段树…写了那么多简析的我不想多说什么了… AC代码352ms123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153// luogu-judger-enable-o2#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#define Rint register int#define mem(a,b) memset(a,(b),sizeof(a))#define Temp template&lt;typename T&gt;using namespace std;typedef long long LL;Temp inline void read(T &amp;x)&#123; x=0;T w=1,ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-')ch=getchar(); if(ch=='-')w=-1,ch=getchar(); while(isdigit(ch))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^'0'),ch=getchar(); x=x*w;&#125;#define mid ((l+r)&gt;&gt;1)#define lson rt&lt;&lt;1,l,mid#define rson rt&lt;&lt;1|1,mid+1,r#define len (r-l+1)const int maxn=200000+10;int n,m,r,mod;int e,beg[maxn],nex[maxn],to[maxn],w[maxn],wt[maxn];int a[maxn&lt;&lt;2],laz[maxn&lt;&lt;2];int son[maxn],id[maxn],fa[maxn],cnt,dep[maxn],siz[maxn],top[maxn]; int res=0;inline void add(int x,int y)&#123;to[++e]=y;nex[e]=beg[x];beg[x]=e;&#125;inline void pushdown(int rt,int lenn)&#123; laz[rt&lt;&lt;1]+=laz[rt];laz[rt&lt;&lt;1|1]+=laz[rt]; a[rt&lt;&lt;1]+=laz[rt]*(lenn-(lenn&gt;&gt;1)); a[rt&lt;&lt;1|1]+=laz[rt]*(lenn&gt;&gt;1); a[rt&lt;&lt;1]%=mod;a[rt&lt;&lt;1|1]%=mod; laz[rt]=0;&#125;inline void build(int rt,int l,int r)&#123; if(l==r)&#123; a[rt]=wt[l]; if(a[rt]&gt;mod)a[rt]%=mod; return; &#125; build(lson);build(rson); a[rt]=(a[rt&lt;&lt;1]+a[rt&lt;&lt;1|1])%mod;&#125;inline void query(int rt,int l,int r,int L,int R)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123;res+=a[rt];res%=mod;return;&#125; else&#123; if(laz[rt])pushdown(rt,len); if(L&lt;=mid)query(lson,L,R); if(R&gt;mid)query(rson,L,R); &#125;&#125;inline void update(int rt,int l,int r,int L,int R,int k)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; laz[rt]+=k; a[rt]+=k*len; &#125; else&#123; if(laz[rt])pushdown(rt,len); if(L&lt;=mid)update(lson,L,R,k); if(R&gt;mid)update(rson,L,R,k); a[rt]=(a[rt&lt;&lt;1]+a[rt&lt;&lt;1|1])%mod; &#125;&#125;inline int qRange(int x,int y)&#123; int ans=0; while(top[x]!=top[y])&#123; if(dep[top[x]]&lt;dep[top[y]])swap(x,y); res=0; query(1,1,n,id[top[x]],id[x]); ans+=res;ans%=mod; x=fa[top[x]]; &#125; if(dep[x]&gt;dep[y])swap(x,y); res=0; query(1,1,n,id[x],id[y]); ans+=res; return ans%mod;&#125;inline void updRange(int x,int y,int k)&#123; k%=mod; while(top[x]!=top[y])&#123; if(dep[top[x]]&lt;dep[top[y]])swap(x,y); update(1,1,n,id[top[x]],id[x],k); x=fa[top[x]]; &#125; if(dep[x]&gt;dep[y])swap(x,y); update(1,1,n,id[x],id[y],k);&#125;inline int qSon(int x)&#123; res=0; query(1,1,n,id[x],id[x]+siz[x]-1); return res;&#125;inline void updSon(int x,int k)&#123; update(1,1,n,id[x],id[x]+siz[x]-1,k);&#125;inline void dfs1(int x,int f,int deep)&#123; dep[x]=deep;fa[x]=f;siz[x]=1; int maxson=-1; for(Rint i=beg[x];i;i=nex[i])&#123; int y=to[i]; if(y==f)continue; dfs1(y,x,deep+1); siz[x]+=siz[y]; if(siz[y]&gt;maxson)son[x]=y,maxson=siz[y]; &#125;&#125;inline void dfs2(int x,int topf)&#123; id[x]=++cnt;wt[cnt]=w[x];top[x]=topf; if(!son[x])return; dfs2(son[x],topf); for(Rint i=beg[x];i;i=nex[i])&#123; int y=to[i]; if(y==fa[x]||y==son[x])continue; dfs2(y,y); &#125;&#125;int main()&#123; read(n);read(m);read(r);read(mod); for(Rint i=1;i&lt;=n;i++)read(w[i]); for(Rint i=1;i&lt;n;i++)&#123; int a,b; read(a);read(b); add(a,b);add(b,a); &#125; dfs1(r,0,1);dfs2(r,r);build(1,1,n); while(m--)&#123; int k,x,y,z; read(k); if(k==1)&#123;read(x);read(y);read(z);updRange(x,y,z);&#125; else if(k==2)&#123;read(x);read(y);printf("%d\n",qRange(x,y));&#125; else if(k==3)&#123;read(x);read(y);updSon(x,y);&#125; else&#123;read(x);printf("%d\n",qSon(x));&#125; &#125;&#125; 后记代码其实不是很长（嘿嘿嘿光是模板就一百五十行？！后面一段接近口糊我不是很好意思…（逃要不是做题目的时候有点生疏了，我也不会把写这篇博客提上日程… 欢迎指正联系方式如下… qq： 953559040 微博： IncinblePan 洛谷： SherlockPan]]></content>
  </entry>
  <entry>
    <title><![CDATA[欧拉函数浅析]]></title>
    <url>%2F2018%2F05%2F21%2F%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[前言是时候学习欧拉函数了…手动滑稽… 侵删 欧拉函数欧拉函数的概念我们先来看一下欧拉函数的概念 在数论，对正整数n，欧拉函数是小于n的正整数中与n互质的数的数目（φ(1)=1）。此函数以其首名研究者欧拉命名(Euler’s totient function)，它又称为Euler’s totient function、φ 函数、欧拉商数等。 例如φ(8)=4，因为1,3,5,7均和8互质。 从欧拉函数引伸出来在环论方面的事实和拉格朗日定理构成了欧拉定理的证明。 好的以上引用均采取百度百科（广告时间… 实际上欧拉函数 φ （n） 求的是小于 n 的与 n 互质的数的个数 欧拉函数的通式与性质我觉得上面那个内容很划水我们来看看能用的东西 通式 (mmp Makedown的数学符号怎么打？！！！急在线等 其中 P1，P2，P3…为 x 的所有质因数，x 为不为0的正整数φ（1）=1，另外每种质因数只算一次…譬如12=2·2·3，我们在进行计算的时候只能每个质数用一次（不信你自己去算 φ（12）=4若n是质数p的k次幂，，因为除了p的倍数外，其他数都跟n互质。欧拉函数为积性函数…若m,n互质， 我们再来介绍一下一些特殊性质 若 n 为奇数时， 若 n 为质数时， 不打算给证明我也不会如题，我不打算给证明，而且上述性质抄的比较多（你叫我自己写？！博客还是主要是给自己看看的…我给个超链接怎么样，我还是嫖百度百科的好了（已注明出处…再次声明侵删 设A, B, C是跟m, n, mn互质的数的集，据中国剩余定理，A*B和C可建立一一对应的关系。因此φ(n)的值使用算术基本定理便知， 若 则 例如 与欧拉定理、费马小定理的关系对任何两个互质的正整数a, m(m&gt;=2)有 即欧拉定理当m是质数p时，此式则为：费马小定理…实际上，考试的时候你怎么可能自己还要去证明这个通式…能拉过来用就行了啊管他那么多你要是证完时间肯定不够啊笨而且我拉网上资料还那么辛苦…现在我们来看一下题目… 题目题目描述作为体育委员，C君负责这次运动会仪仗队的训练。仪仗队是由学生组成的N * N的方阵，为了保证队伍在行进中整齐划一，C君会跟在仪仗队的左后方，根据其视线所及的学生人数来判断队伍是否整齐(如下图)。 现在，C君希望你告诉他队伍整齐时能看到的学生人数。 输入输出格式输入格式：共一个数N 输出格式：共一个数，即C君应看到的学生人数。 输入输出样例输入样例#1：4 输出样例#1：9 说明【数据规模和约定】 对于 100% 的数据，1 ≤ N ≤ 40000 解题思路 其实我们可以发现，上面讲的性质很多都是没有多大用处的… 观察可知，如果我们的视线被一个人挡住了，那么在这一条线上(光沿直线传播…）看不到的人斜率是和我们看到那个人的是一样的 换句话说，我们设看到第一个人的坐标为 （X1，Y1），那么之后的每个人的坐标一定是（X1·k , Y1·k)（k 为正整数） 因此，我们在一条光线上看到的第一个人的 x 轴的坐标与 y 轴的坐标一定是互质的（这时以上的 k 的值为1），而之后的人的坐标 x 与 y 是有别的公因数（除去1）的 另外，我们把图用直线 y=x 分割，可以发现我们分成的两部分是对称的，只需要求出其中一个部分的值 sum ，把 sum 乘2再加上直线 y = x 上我们还能看到的那个点 （1,1），答案就是 2*sum + 1 而对于每一个部分，要么 x &lt; y,要么 y &lt; x ，因此我们就可以用欧拉函数了…我们要求的就是小于 x 的所有正整数与 x 互质的个数 我们还要加个特判因为当 n = 1 的时候情况不一样… 筛选打欧拉函数表0ms我们先预处理每个数的欧拉函数，求值的时候直接加上 123456789101112131415161718192021222324252627282930313233343536// luogu-judger-enable-o2#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define re register int#define rep(i,a,b) for(re i=(a);i&lt;=(b);++(i))using namespace std;int n,ans=0;int euler[40010];inline void Init()&#123; euler[1]=1; for(int i=2;i&lt;n;i++) euler[i]=i; for(int i=2;i&lt;n;i++) if(euler[i]==i) for(int j=i;j&lt;n;j+=i) euler[j]=euler[j]/i*(i-1);//先进行除法防止溢出下同 return;&#125;int main()&#123; scanf("%d",&amp;n); if(n==1)&#123; puts("0"); return 0; &#125; Init(); rep(i,1,n-1)&#123; ans+=euler[i]; &#125; printf("%d",2*ans+1); return 0;&#125; 直接求每个数的欧拉函数32ms我觉得这个复杂度也是可以让人接受的… 1234567891011121314151617181920212223242526272829303132333435// luogu-judger-enable-o2#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define re register int#define rep(i,a,b) for(re i=(a);i&lt;=(b);++(i))using namespace std;int n,ans=0;;inline int euler(int n)&#123; int res=n,a=n; for(int i=2;i*i&lt;=a;i++)&#123; if(a%i==0)&#123; res=res/i*(i-1); while(a%i==0) a/=i; &#125; &#125; if(a&gt;1) res=res/a*(a-1); return res; &#125;int main()&#123; scanf("%d",&amp;n); if(n==1)&#123; puts("0"); return 0; &#125; rep(i,1,n-1)&#123; ans+=euler(i); &#125; printf("%d",2*ans+1); return 0;&#125; 后记我觉得洛谷上这道题的难度评得有点高了，一道纯裸的欧拉函数，代码也短…我觉得OI中数论的知识还是比较重要的…多学点总是好的…欢迎指正联系方式如下 qq： 953559040 微博： IncinblePan 洛谷： SherlockPan]]></content>
  </entry>
  <entry>
    <title><![CDATA[NOI 2014 魔法森林]]></title>
    <url>%2F2018%2F05%2F19%2F%E9%AD%94%E6%B3%95%E6%A3%AE%E6%9E%97%2F</url>
    <content type="text"><![CDATA[前言我觉得我的博客需要加上标签…这本来想用来练LCT的… 题目题目描述为了得到书法大家的真传，小 E 同学下定决心去拜访住在魔法森林中的隐 士。魔法森林可以被看成一个包含 n 个节点 m 条边的无向图，节点标号为 1,2,3,…,n，边标号为 1,2,3,…,m。初始时小 E 同学在 1 号节点，隐士则住在 n 号节点。小 E 需要通过这一片魔法森林，才能够拜访到隐士。 魔法森林中居住了一些妖怪。每当有人经过一条边的时候，这条边上的妖怪 就会对其发起攻击。幸运的是，在 1 号节点住着两种守护精灵：A 型守护精灵与 B 型守护精灵。小 E 可以借助它们的力量，达到自己的目的。 只要小 E 带上足够多的守护精灵，妖怪们就不会发起攻击了。具体来说，无 向图中的每一条边 ei 包含两个权值 ai 与 bi 。若身上携带的 A 型守护精灵个数不 少于 ai ，且 B 型守护精灵个数不少于 bi ，这条边上的妖怪就不会对通过这条边 的人发起攻击。当且仅当通过这片魔法森林的过程中没有任意一条边的妖怪向 小 E 发起攻击，他才能成功找到隐士。 由于携带守护精灵是一件非常麻烦的事，小 E 想要知道，要能够成功拜访到 隐士，最少需要携带守护精灵的总个数。守护精灵的总个数为 A 型守护精灵的 个数与 B 型守护精灵的个数之和。 输入输出格式输入格式：输入文件的第 1 行包含两个整数 n,m，表示无向图共有 n 个节点，m 条边。 接下来 m 行，第i+ 1 行包含 4 个正整数 Xi,Yi,ai,bi，描述第i条无向边。 其中Xi与 Yi为该边两个端点的标号，ai 与 bi 的含义如题所述。 注意数据中可能包含重边与自环。 输出格式：输出一行一个整数：如果小 E 可以成功拜访到隐士，输出小 E 最少需要携 带的守护精灵的总个数；如果无论如何小 E 都无法拜访到隐士，输出“-1”（不含引号）。 输入输出样例输入样例#1：4 5 1 2 19 1 2 3 8 12 2 4 12 15 1 3 17 8 3 4 1 17 输出样例#1：32 输入样例#2：3 1 1 2 1 1 输出样例#2：-1 说明 解释1 如果小 E 走路径 1→2→4，需要携带 19+15=34 个守护精灵； 如果小 E 走路径 1→3→4，需要携带 17+17=34 个守护精灵； 如果小 E 走路径 1→2→3→4，需要携带 19+17=36 个守护精灵； 如果小 E 走路径 1→3→2→4，需要携带 17+15=32 个守护精灵。 综上所述，小 E 最少需要携带 32 个守护精灵。 解释2 小 E 无法从 1 号节点到达 3 号节点，故输出-1。 数据范围100%的数据：n&lt;=50000,m&lt;=100000, 0&lt;=a,b&lt;=50000 解题我们有两种方法来解这道题…还有这道题数据范围是一张带洛谷水印的图…随意手打… spfa单源最短路思路 首先跑Spfa的时间复杂度无法保证 AC代码1028ms123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// luogu-judger-enable-o2#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;cctype&gt;#define re register int#define rep(i,a,b) for(re i=(a);i&lt;=(b);++(i))#define xep(i,x) for(re i=head[x];i;i=e[i].nxt)#define INF 0x3f3f3f3fusing namespace std;inline int read()&#123; int X=0,w=0; char ch=0; while(!isdigit(ch)) &#123;w|=ch=='-';ch=getchar();&#125; while(isdigit(ch)) X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;const int N=50010;const int M=100010;int n,m,head[2*M],cnt=0,ans=INF;int vis[N],sum[N];queue &lt; int &gt; q;struct edge&#123; int nxt,to,val1,val2;&#125;e[2*M];struct line&#123; int x,y,a,b; inline bool operator &lt;(const line &amp;rhy)const&#123; return a&lt;rhy.a; &#125;&#125;l[M];inline void add(int x,int y,int v1,int v2)&#123; e[++cnt].nxt=head[x];e[cnt].to=y; e[cnt].val1=v1;e[cnt].val2=v2;head[x]=cnt;&#125;inline void spfa(int x,int y)&#123; vis[x]=1;vis[y]=1; q.push(x);q.push(y); while(!q.empty())&#123; int u=q.front();vis[u]=0;q.pop(); xep(i,u)&#123; int v=e[i].to; if(max(e[i].val2,sum[u])&lt;sum[v])&#123; sum[v]=max(e[i].val2,sum[u]); if(!vis[v]) vis[v]=1,q.push(v); &#125; &#125; &#125;&#125;int main()&#123; n=read();m=read(); rep(i,1,m)&#123; int x,y,z,p; x=read();y=read();z=read();p=read(); l[i].a=z;l[i].b=p;l[i].x=x;l[i].y=y; &#125; sort(l+1,l+1+m); memset(sum,INF,sizeof(sum)); sum[1]=0;vis[1]=1;q.push(1); rep(i,1,m)&#123; add(l[i].x,l[i].y,l[i].a,l[i].b); add(l[i].y,l[i].x,l[i].a,l[i].b); spfa(l[i].x,l[i].y); ans=min(ans,sum[n]+l[i].a); &#125; if(ans==INF) puts("-1"); else printf("%d\n",ans); return 0;&#125; （PS：洛谷数据水… LCT 后记]]></content>
  </entry>
  <entry>
    <title><![CDATA[SDOI2008 洞穴勘测]]></title>
    <url>%2F2018%2F05%2F18%2FSDOI2008%2F</url>
    <content type="text"><![CDATA[前言刚刚学会了LCT，找了一道很基础的题来练练手…我好菜啊 题目题目描述辉辉热衷于洞穴勘测。 某天，他按照地图来到了一片被标记为JSZX的洞穴群地区。经过初步勘测，辉辉发现这片区域由n个洞穴（分别编号为1到n）以及若干通道组成，并且每条通道连接了恰好两个洞穴。假如两个洞穴可以通过一条或者多条通道按一定顺序连接起来，那么这两个洞穴就是连通的，按顺序连接在一起的这些通道则被称之为这两个洞穴之间的一条路径。 洞穴都十分坚固无法破坏，然而通道不太稳定，时常因为外界影响而发生改变，比如，根据有关仪器的监测结果，123号洞穴和127号洞穴之间有时会出现一条通道，有时这条通道又会因为某种稀奇古怪的原因被毁。 辉辉有一台监测仪器可以实时将通道的每一次改变状况在辉辉手边的终端机上显示： 如果监测到洞穴u和洞穴v之间出现了一条通道，终端机上会显示一条指令 Connect u v 如果监测到洞穴u和洞穴v之间的通道被毁，终端机上会显示一条指令 Destroy u v 经过长期的艰苦卓绝的手工推算，辉辉发现一个奇怪的现象：无论通道怎么改变，任意时刻任意两个洞穴之间至多只有一条路径。 因而，辉辉坚信这是由于某种本质规律的支配导致的。因而，辉辉更加夜以继日地坚守在终端机之前，试图通过通道的改变情况来研究这条本质规律。 然而，终于有一天，辉辉在堆积成山的演算纸中崩溃了……他把终端机往地面一砸（终端机也足够坚固无法破坏），转而求助于你，说道：“你老兄把这程序写写吧”。 辉辉希望能随时通过终端机发出指令 Query u v，向监测仪询问此时洞穴u和洞穴v是否连通。现在你要为他编写程序回答每一次询问。 已知在第一条指令显示之前，JSZX洞穴群中没有任何通道存在。 输入输出格式输入格式：第一行为两个正整数n和m，分别表示洞穴的个数和终端机上出现过的指令的个数。 以下m行，依次表示终端机上出现的各条指令。每行开头是一个表示指令种类的字符串s（”Connect”、”Destroy”或者”Query”，区分大小写），之后有两个整数u和v (1≤u, v≤n且u≠v) 分别表示两个洞穴的编号。 输出格式：对每个Query指令，输出洞穴u和洞穴v是否互相连通：是输出”Yes”，否则输出”No”。（不含双引号） 输入输出样例输入样例#1：200 5 Query 123 127 Connect 123 127 Query 123 127 Destroy 127 123 Query 123 127 输出样例#1：No Yes No 输入样例#2：3 5 Connect 1 2 Connect 3 1 Query 2 3 Destroy 1 3 Query 2 3 输出样例#2：Yes No 数据说明10%的数据满足n≤1000, m≤20000 20%的数据满足n≤2000, m≤40000 30%的数据满足n≤3000, m≤60000 40%的数据满足n≤4000, m≤80000 50%的数据满足n≤5000, m≤100000 60%的数据满足n≤6000, m≤120000 70%的数据满足n≤7000, m≤140000 80%的数据满足n≤8000, m≤160000 90%的数据满足n≤9000, m≤180000 100%的数据满足n≤10000, m≤200000 保证所有Destroy指令将摧毁的是一条存在的通道 本题输入、输出规模比较大，建议c\c++选手使用scanf和printf进行I\O操作以免超时 解题mmp题目好长啊对于会LCT的人来说，这可能是一道纯的模板…但是好像说，并查集更快？！算了算了我还是直接贴出代码好了开氧跑了808ms… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// luogu-judger-enable-o2#include&lt;bits/stdc++.h&gt;#define re register int#define rep(i,a,b) for(re i=(a);i&lt;=(b);++(i))#define drep(i,a,b) for(re i=(a);i&gt;=(b);--(i))using namespace std;inline int read()&#123; int X=0,w=0; char ch=0; while(!isdigit(ch)) &#123;w|=ch=='-';ch=getchar();&#125; while(isdigit(ch)) X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;const int N=10010;char s[10];int n,m,x,y;struct node&#123; int ch[N][2],fa[N],tag[N],stk[N],top; inline bool isroot(int x)&#123;return ch[fa[x]][0]!=x&amp;&amp;ch[fa[x]][1]!=x;&#125; inline void push_down(int x)&#123; if(tag[x])&#123; tag[ch[x][0]]^=1;tag[ch[x][1]]^=1; swap(ch[x][0],ch[x][1]);tag[x]=0; &#125; &#125; inline void rotate(int x)&#123; re y=fa[x],z=fa[y],k=ch[y][1]==x; if(!isroot(y)) ch[z][ch[z][1]==y]=x; ch[y][k]=ch[x][k^1], fa[ch[x][k^1]]=y; ch[x][k^1]=y;fa[x]=z;fa[y]=x; &#125; inline void splay(int x)&#123; stk[top=1]=x;for(re i=x;!isroot(i);i=fa[i]) stk[++top]=fa[i]; drep(i,top,1) push_down(stk[i]); for(int y=fa[x],z=fa[y];!isroot(x);y=fa[x],z=fa[y])&#123; if(!isroot(y)) ((ch[y][0]==x)^(ch[z][0]==y))?rotate(x):rotate(y); rotate(x); &#125; &#125; inline int access(int x)&#123; int t=0; while(x)&#123; splay(x);ch[x][1]=t;t=x;x=fa[x]; &#125; return t; &#125; inline int find(int x)&#123; access(x);splay(x);int now=x; while(ch[now][0]) now=ch[now][0]; return now; &#125; inline void makeroot(int x)&#123;access(x);splay(x);tag[x]^=1;&#125; inline void link(int x,int y)&#123;makeroot(x); if(find(x)!=find(y)) fa[x]=y;&#125; inline void cut(int x,int y)&#123; makeroot(x);access(y);splay(y); if(fa[x]!=y||ch[x][1]) return; fa[x]=0;ch[y][0]=0; &#125; inline bool query(int x,int y)&#123;return (find(x)==find(y))?1:0;&#125;&#125;LCT;int main()&#123; n=read();m=read(); while(m--)&#123; scanf("%s",s);x=read();y=read(); if(s[0]=='C') LCT.link(x,y); else if(s[0]=='Q')&#123; if(LCT.query(x,y)) puts("Yes"); else puts("No"); &#125; else if(s[0]=='D') LCT.cut(x,y); &#125; return 0;&#125; 后记mmp大水题我修了好久但是感觉自己对于 splay-tree 和 LCT 会打了很多我好菜啊…我觉得这篇博客意义不大但是我打的时间也少欢迎指正…以下本人联系方式 qq： 953559040 微博： IncinblePan 洛谷： SherlockPan]]></content>
  </entry>
  <entry>
    <title><![CDATA[Link Cut Tree （动态树）简析]]></title>
    <url>%2F2018%2F05%2F18%2FLCT%2F</url>
    <content type="text"><![CDATA[前言：我是真的菜…修锅修了好久…所以写前言真的只是随便的并没有什么内容…另外这篇题解可能会折腾我很久… 侵删 LCT动态树LCT的定义 LCT是把一棵树分解成很多条树链，而每条树链用 Splay 维护，如果我们需要对一棵树的路径进行操作的时候，利用 Splay 进行分离与合并，把这条路径储存在同一棵 Splay 上，然后再进行操作这棵 Splay LCT的概念我们现在来看一下LCT有什么概念… Preferred Child：偏好子节点 Preferred Edge：偏好边 Preferred Path：偏好路径 Auxiliary Tree：辅助树 Path Parent：路径父节点 为了加深理解，我们来看一下这样一张图 上图中节点1是树的根，1的偏好子节点是2 , 2的偏好子节点有4 ，而3,5,6 并没有偏好子节点偏好子节点连成的边叫做偏好边和树链剖分相似的，LCT也把树分成很多条线型的链，但是LCT采用了Splay-Tree来储存这些链 我们再来看一张图 我们把蓝色标记出的链处理成一棵 Splay ，可以发现，离根节点近的边被储存到 Splay 的左边，离根节点较远的被储存到右边，Splay-tree 是以deep 作为关键字排序的。这样的链我们我们称之为偏好路径 储存多条树链我们称 Splay 的根的父亲为路径父节点如何储存这棵树，我们来看下面一张图 我们把树链当成一个点，轻边（即不是偏好边的边）当成树上的边，可以发现，我们得到的新树要比原先的树小的多，现在我们称修改后的树为虚树如果一棵虚树的数据结构不再发生改变的话，同树链剖分，每个节点都用线型的数据结构加速的话，就能达到 log 级别的效率，我们可以把树链剖分理解成静态的LCT…但是LCT最重要的一点是，它总能在 log 的时间级里，把需要查询的区间构造成主链，我们现在来看看如何实现 LCT的基本操作构造主链的操作并不是只基于一种基础操作，而且LCT不仅仅只需要构造主链这种操作，我们来看看LCT有哪些基本操作 accessaccess操作是LCT所有操作的基础如果我们调用access操作，那么操作完成后，根节点到节点 i 就变成了一条偏好路径，这条路径上的所有点就变成了偏好孩子。同时，这条路径变成了一棵 Splay假设我们访问到节点 i ，先把节点 i 伸展到该树的根，再断开它的右孩子（访问到的节点是没有右孩子的…)，然后我们再访问 i 的路径父节点 x ，把节点 i 接在 x 的右节点上，不断重复该操作，最后，我们就能得到一条从根节点连到 i 的一条树链 上图是一棵虚树，假设我们需要access（2） 先旋转点 2 至所在 Splay-Tree 的根，再断开点 3 的右孩子，旋转点3 至它的根，将点 2 连接上 现在我们要访问的节点 2 已经在根为 3 的 Splay 上，来看看整棵树的形状 我们现在再旋转点 1，把点 1 的右孩子接在点 3 上，可以发现，整棵树的根 1 已经和我们访问的点 2，在同一条树链上了 看样子操作很长其实也只要写一个循环就可以了，我们来看一下 12345inline int access(int x)&#123; int t=0; while(x)&#123;splay(x);ch[x][1]=t;t=x;x=fa[x];&#125; return t;&#125; findroot查找树根操作找的是原树的树根（即主链中 deep 的最小点），并不是LCT的树根 我们在access（ i ），之后，根节点是 包括 i 的辅助树中的 deep 的最小点，因此，我们只需要先把 i 旋转到它所在数的根，再从 i 开始一直往左走，最后的节点就是我们要询问的结果 我们来看一下代码实现 1234inline int find(int x)&#123; access(x);splay(x);int now=x; while(ch[now][0]!=0) now=ch[now][0];return now;&#125; makerootmakeroot的意思是改变原树的树根，有时候我们需要这样做来进行更多操作我们在改变树根的时候，最好把原先的根节点和要改变成树根的节点在同一条链上，这样我们就不会牵扯到很多的树链，操作也不会变得复杂，因此，我们用access操作将我们要改变的点 i 和根 x 在存在于同一条链上我们先来看一张图 假设我们要将根点 1 换成点 6，换完之后的样式是上图可以发现，除去主链之外的所有链，在换根操作的时候都是不受影响的但是红色标记的主链，是被翻转的。这意味着，我们每换一次根，在主链这棵 Splay 上都是被翻转的，这需要我们在 Splay 里的操作里用上区间翻转…我们用上类似于线段树的延迟标记，在进行 Splay 的操作中进行释放现在我们先来看一下代码实现 123inline void makeroot(int x)&#123; access(x);splay(x);tag[x]^=1;&#125; linklink 操作的目的是合并两棵 LCT，我们来看一下思路（以下思路基于这两棵LCT不同如果我们要合并两个点 x 和 y ，只需要将 x makeroot 到根，再使点 x 的父亲节点为 y ，这时 x 所在的 Splay 和 y 有一条边相连，但是合并后的树并没有一个根，这时我们就需要把 y 当做新树的根，splay（y)即可(其实重新换树根也是可以的…我们来看两张图增进理解 我们来看一下代码 123inline void link(int x,int y)&#123; if(find(x)!=find(y)) makeroot(x),fa[x]=y,splay(y);&#125; cutcut 操作和 link 操作相反，它的目的是断开一棵LCT假设我们需要断开点 x 与点 y 的边我们先把点 x makeroot，再access( y ) ,这时 x 和 y 就在同一条链上了 假设我们要断开点 1 ，和点 5 然后我们再断开 断开操作就完成了，我们看一下代码实现，其实很短… 12345inline void cut(int x,int y)&#123; makeroot(x);access(y);splay(y); if(fa[x]!=y||!ch[y][0]) return; ch[y][0]=0;fa[x]=0;&#125; 另外的，我们需要进行特判（我就在这里卡了很久…我好菜啊点 x 在这之后就不是树的根了，若点 x 的父亲节点不是 y 的时候，这两点已经没有边相连，我们直接返回即可还有，一个点的左儿子是从根部来的，右儿子是到 deep 更深的地方，如果点 y 的左儿子没有的话，我们也需要直接返回，直接进行 cut 操作会破坏原树的性质 Splay-Tree的操作在LCT中，Splay 的操作和一般的 Splay 操作略不同（我在这里卡了死循环…）我们来看看有哪些不同的操作 isroot 我们在 Splay 中判断根的方式是该根是否有父亲节点，但是在LCT中有很多棵 Splay ，在这棵 Splay 中的根可能指向别的树的节点，这样我们就找不到根了…所以我们需要反过来，判断该点的父亲节点的儿子是否有该点，即求该点的父亲节点的偏好子节点是否为该点，我们来看一下代码实现 123inline bool isroot(int x)&#123; return ch[fa[x]][0]!=x&amp;&amp;ch[fa[x]][1]!=x;&#125; rotate 我们在进行旋转操作的时候还是要多加入一句话如果旋转的点 i 的爷爷节点与 i 并不是在同一棵树上的话，我们就不需要把 i 的爷爷节点的儿子指向 i （否则破坏性质来看一下整个的代码实现（其实80%差不多 123456inline void rotate(int x)&#123; int y=fa[x],z=fa[y],d=(ch[y][1]==x); if (!check(y)) ch[z][ch[z][1]==y]=x; ch[y][d]=ch[x][!d],fa[ch[x][!d]]=y; ch[x][!d]=y,fa[y]=x;fa[x]=z;update(y); &#125; Splay Splay 操作也是有很多不同的（因此我拉了模板的 Splay 之后才发现死循环的原因…我们在进行伸展的时候，是不能伸展到别的树的，然后我们需要释放标记（我们上面讲过的翻转标记用一个小堆栈维护，我们一直向上找父亲节点，然后把这一条路径上的标记释放，看一下代码实现 12345678inline void splay(int x)&#123; stack[top=1]=x; for (int i=x;!check(i);i=fa[i]) stack[++top]=fa[i]; for (int i=top;i&gt;=1;i--) push_down(stack[i]); for (int y=fa[x],z=fa[y];!check(x);y=fa[x],z=fa[y])&#123; if (!check(y))&#123;((ch[z][0]==y)^(ch[y][0]==x))?rotate(x):rotate(y);&#125; rotate(x); &#125; update(x);&#125; 再看一下标记的释放 123456inline void push_down(int x)&#123; if(tag[x]) &#123; tag[ch[x][0]]^=1,tag[ch[x][1]]^=1; swap(ch[x][0],ch[x][1]);tag[x]=0; &#125;&#125; 其他操作简述实际上我们还可以用 LCT 求LCA，我在这里就不多解释了（我也不会… 关于询问实际上就是求 Splay 维护的信息，也是很简单的 这样我觉得我讲的还是蛮详细的，这是入门的LCT，我们现在来看一下模板题 题目题目描述给定n个点以及每个点的权值，要你处理接下来的m个操作。操作有4种。操作从0到3编号。点从1到n编号。 0：后接两个整数(x，y)，代表询问从x到y的路径上的点的权值的xor和。保证x到y是联通的。 1：后接两个整数(x，y)，代表连接x到y，若x到y已经联通则无需连接。 2：后接两个整数(x，y)，代表删除边(x，y)，不保证边(x，y)存在。 3：后接两个整数(x，y)，代表将点x上的权值变成y。 输入输出格式输入格式：第1行两个整数，分别为n和m，代表点数和操作数。 第2行到第n+1行，每行一个整数，整数在［1，10^9］内，代表每个点的权值。 第n+2行到第n+m+1行，每行三个整数，分别代表操作类型和操作所需的量。 输出格式：对于每一个0号操作，你须输出x到y的路径上点权的xor和。 输入输出样例输入样例#1：3 3 1 2 3 1 1 2 0 1 2 0 1 1 输出样例#1：3 1 说明数据范围：1 ≤ N , M ≤ 3*105 解题过程 赤裸裸的模板… 它叫你干嘛你就干嘛… 所有操作在上面都有讲过… 但是好像LCT跑的不是很快…（起码我觉得 话说LCT的代码可以压成19行也是蛮好看的… LCT这种数据结构一定要多练也很容易写错的… AC代码氧气656ms1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#define re register int#define rep(i,a,b) for(re i=(a);i&lt;=(b);++(i))#define drep(i,a,b) for(re i=(a);i&gt;=(b);--(i))using namespace std;const int N=300010;int n,m;struct LCT&#123; int a[N],fa[N],ch[N][2],tag[N],sum[N],stack[N],top; inline bool check(int x)&#123;return ch[fa[x]][0]!=x&amp;&amp;ch[fa[x]][1]!=x;&#125; inline void push_down(int x)&#123; if(tag[x]) &#123; tag[ch[x][0]]^=1,tag[ch[x][1]]^=1; swap(ch[x][0],ch[x][1]);tag[x]=0; &#125; &#125; inline void update(int x)&#123;sum[x]=sum[ch[x][0]]^sum[ch[x][1]]^a[x];&#125; inline void rotate(int x)&#123; int y=fa[x],z=fa[y],d=(ch[y][1]==x); if (!check(y)) ch[z][ch[z][1]==y]=x; ch[y][d]=ch[x][!d],fa[ch[x][!d]]=y; ch[x][!d]=y,fa[y]=x;fa[x]=z;update(y); &#125; inline void splay(int x)&#123; stack[top=1]=x; for (int i=x;!check(i);i=fa[i]) stack[++top]=fa[i]; for (int i=top;i&gt;=1;i--) push_down(stack[i]); for (int y=fa[x],z=fa[y];!check(x);y=fa[x],z=fa[y])&#123; if (!check(y))&#123;((ch[z][0]==y)^(ch[y][0]==x))?rotate(x):rotate(y);&#125; rotate(x); &#125;update(x); &#125; inline int access(int x)&#123; int t=0; while(x)&#123;splay(x);ch[x][1]=t;t=x;x=fa[x];&#125; return t; &#125; inline int find(int x)&#123; access(x);splay(x);int now=x; while(ch[now][0]!=0) now=ch[now][0];return now; &#125; inline void makeroot(int x)&#123;access(x);splay(x);tag[x]^=1;&#125; inline void link(int x,int y)&#123;makeroot(x); if(find(x)!=find(y)) fa[x]=y;&#125; inline void cut(int x,int y)&#123; makeroot(x);access(y);splay(y); if(fa[x]!=y||ch[x][1]) return; fa[x]=0;ch[y][0]=0; &#125; inline void change(int x,int y)&#123;sum[x]=sum[x]^a[x]^y;a[x]=y;&#125; inline int query(int x,int y)&#123;makeroot(x);access(y);splay(y);return sum[y];&#125;&#125;LCT;int main()&#123; scanf("%d%d",&amp;n,&amp;m); rep(i,1,n) scanf("%d",&amp;LCT.a[i]); while(m--)&#123; int opt,x,y; scanf("%d%d%d",&amp;opt,&amp;x,&amp;y); if(opt==0) &#123;printf("%d\n",LCT.query(x,y));&#125; else if(opt==1) &#123;if(LCT.find(x)!=LCT.find(y)) LCT.link(x,y);&#125; else if(opt==2) &#123;LCT.cut(x,y);&#125; else if(opt==3) &#123;LCT.change(x,y);&#125; &#125; return 0;&#125; 为了方便看我就放在结构体里写函数了，可能加个读优616ms… 后记关于LCT其实也蛮详细的了我本来想再拉一道LCT的例题那就改天吧欢迎指正…我觉得我好菜啊有时候一天一篇博客也是挺累的…而且昨天博客出锅修了我好久…本人联系方式如下（因为懒得挂评论啊… qq： 953559040 微博： IncinblePan 洛谷： SherlockPan]]></content>
  </entry>
  <entry>
    <title><![CDATA[CQOI2015 任务查询系统]]></title>
    <url>%2F2018%2F05%2F17%2F%E4%B8%BB%E5%B8%AD%E6%A0%91P3168%2F</url>
    <content type="text"><![CDATA[前言：说实在话前言只是用来加个 read more 不让你们在看预览的时候就知道题目… 题目：题目描述最近实验室正在为其管理的超级计算机编制一套任务管理系统，而你被安排完成其中的查询部分。超级计算机中的任务用三元组(Si,Ei,Pi)描述，(Si,Ei,Pi)表示任务从第Si秒开始，在第Ei秒后结束（第Si秒和Ei秒任务也在运行），其优先级为Pi。同一时间可能有多个任务同时执行，它们的优先级可能相同，也可能不同。调度系统会经常向查询系统询问，第Xi秒正在运行的任务中，优先级最小的Ki个任务（即将任务按照优先级从小到大排序后取前Ki个）的优先级之和是多少。特别的，如果Ki大于第Xi秒正在运行的任务总数，则直接回答第Xi秒正在运行的任务优先级之和。上述所有参数均为整数，时间的范围在1到n之间（包含1和n）。 输入输出格式输入格式：输入文件第一行包含两个空格分开的正整数m和n，分别表示任务总数和时间范围。接下来m行，每行包含三个空格分开的正整数Si、Ei和Pi(Si&lt;=Ei)，描述一个任务。接下来n行，每行包含四个空格分开的整数Xi、Ai、Bi和Ci，描述一次查询。查询的参数Ki需要由公式 Ki=1+(Ai*Pre+Bi) mod Ci计算得到。其中Pre表示上一次查询的结果，对于第一次查询，Pre=1。 输出格式：输出共n行，每行一个整数，表示查询结果。 输入输出样例输入样例#1：4 3 1 2 6 2 3 3 1 3 2 3 3 4 3 1 3 2 1 1 3 4 2 2 4 3 输出样例#1：2 8 11 说明样例解释K1 = (1*1+3)%2+1 = 1 K2 = (1*2+3)%4+1 = 2 K3 = (2*8+4)%3+1 = 3 对于100%的数据，1&lt;=m,n,Si,Ei,Ci&lt;=100000，0&lt;=Ai,Bi&lt;=100000，1&lt;=Pi&lt;=10000000，Xi为1到n的一个排列 解题分析：暴力：暴力分析 我们来看一下这道题的暴力 时间复杂度为 O（nm ) 看样子很不可行（mmp 数据为100000… 但是我们还是要记得暴力出奇迹洛谷的数据水得可怜…凡事都是要先考虑暴力的不是吗 我用了一些（假）优化和剪枝的… 另外这道题是强制在线（？蒟蒻逃… 我们按照任务的优先级先排个序，然后每读到一个满足条件的任务就直接加上，按理说要比时间复杂度比 O（nm）低 好了我们上代码 暴力代码12345678910111213141516171819202122232425262728293031323334353637// luogu-judger-enable-o2#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define re register int#define rep(i,a,b) for(re i=(a);i&lt;=(b);++(i))#define ll long long using namespace std;const int N=100010;int n,m,num,x,y,z;ll last=1,now;struct mess&#123; int s,e,p; &#125;a[N];inline bool cmp(mess x,mess y)&#123; return x.p&lt;y.p;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); rep(i,1,n) scanf("%d%d%d",&amp;a[i].s,&amp;a[i].e,&amp;a[i].p); sort(a+1,a+1+n,cmp); rep(i,1,m) &#123; int cnt=0;ll ans=0; scanf("%d%d%d%d",&amp;num,&amp;x,&amp;y,&amp;z); now=(x*last+y)%z+1; rep(i,1,n)&#123; if(cnt&gt;=now) break; else if(a[i].s&lt;=num&amp;&amp;a[i].e&gt;=num) ans+=a[i].p,cnt++; &#125; printf("%lld\n",ans);last=ans; &#125; return 0;&#125; 不开long long 70分…时间跑的很快比主席树快多了…空间也很小 我就不在这里口糊了毕竟暴力也不是什么好方法… 主席树：正解分析 这道题的正解是主席树…暴力跑得过去说明运气好 说不准明天数据就加强了 要么我现在就去叫 chen_zhe… 并不是很能看的出来但是实际上加个差分就是主席树的模板了… 主席树我之前也讲过了就不多赘述了…我们现在就讲讲怎么差分 我们使前 K 大的主席树维护数据个数size和数据和val，将区间累加和的修改改成两点修改，再运用前缀和的思想 假设我们要将区间 l ~ r 各加上 k ，只要将 a [ l ]+k , a [ r+1 ]-k ,sum [ r ]=a [ 1 ] +….+ a [ r ] ，就维护好了 val 维护 size 也很简单，只需要判断在 该位置上减去了几次就行了…（反正都用前缀和维护了… 另外，long long 不可少… 我好菜啊这道题我看了好久 我们来看一下代码 正解代码氧气优化1448ms12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// luogu-judger-enable-o2#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define re register int#define rep(i,a,b) for(re i=(a);i&lt;=(b);++(i))#define ll long longusing namespace std; const int N=100010;int n,m,root[N],tot=0,cnt=0;ll ans=1,s[N],x,y,z,now,num;struct node&#123; int l,r; ll val,size;&#125;T[4*N*60];struct prefix&#123; int dis,k,type; inline bool operator &lt;(const prefix &amp;rhy)const&#123;return dis&lt;rhy.dis;&#125;&#125;a[N*4]; inline void insert(int &amp;p,int x,int type,int l,int r)&#123; T[++cnt]=T[p];p=cnt;T[p].size+=(ll)type;T[p].val+=(ll)type*s[x]; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(mid&gt;=x) insert(T[p].l,x,type,l,mid); else insert(T[p].r,x,type,mid+1,r);&#125; inline ll query(int p,int k,int l,int r)&#123; if(l==r) return (T[p].val/T[p].size)*(ll)k; int t=T[T[p].l].size,mid=(l+r)&gt;&gt;1; if(k&lt;=t) return query(T[p].l,k,l,mid); else return T[T[p].l].val+query(T[p].r,k-t,mid+1,r);&#125; int main()&#123; scanf("%d%d",&amp;n,&amp;m);root[0]=0; rep(i,1,n)&#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); s[i]=z;a[++tot].dis=x,a[tot].k=z,a[tot].type=1; a[++tot].dis=y+1,a[tot].k=z,a[tot].type=-1; &#125; sort(s+1,s+1+n);sort(a+1,a+1+tot); for(int i=1,j=1;i&lt;=n;i++)&#123; root[i]=root[i-1]; for(;j&lt;=tot&amp;&amp;a[j].dis==i;j++)&#123; int rk=lower_bound(s+1,s+1+n,a[j].k)-s; insert(root[i],rk,a[j].type,1,n); &#125; &#125; while(m--)&#123; scanf("%lld%lld%lld%lld",&amp;num,&amp;x,&amp;y,&amp;z); now=(x*ans+y)%z+1; if(now&gt;=T[root[num]].size) ans=T[root[num]].val; else ans=query(root[num],now,1,n); printf("%lld\n",ans); &#125; return 0;&#125; mmp空间开小了只有40分一开始还以为是long long的锅… 我真的菜啊准备退役… 后记： 有时候一些高级数据结构还是蛮有用的 我也不知道为什么要加个后记随便看看好了 对了欢迎指正…（我并没有在博客中加入评论… 好像博客的子数统计也不是很准… 还有一件很重要的事我菜爆了我弃坑了…哦朋友再见 qq： 953559040 微博： IncinblePan 洛谷： SherlockPan]]></content>
  </entry>
  <entry>
    <title><![CDATA[主席树与整体二分浅析]]></title>
    <url>%2F2018%2F05%2F16%2F%E4%B8%BB%E5%B8%AD%E6%A0%91%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86%2F</url>
    <content type="text"><![CDATA[前言：我觉得随便讲一下前言…对了我好菜弃坑弃坑 我们先来看一道题目，在分析题目时去深入理解主席树和整体二分算法 题目描述：题目大意：给你n个数，多次询问某段区间第k小的数。 输入格式：第一行两个数n、m，n代表有多少个数，m代表询问数。 第二行n个数给出，不超过10^9。 接下来m行，每行三个数i,j,k，询问第i个数到第j个数中第k小的数是什么。 输出格式：输出共m行，对每次询问的回答。 数据范围：1&lt;=n&lt;=100000,1&lt;=m&lt;=5000。 主席树做法主席树简析： 其实这是一道赤裸裸的静态区间求第 K 大值的主席树模板 主席树又叫做可持久化线段树，它支持查询历史版本，我们运用权值线段树来构造主席树 若只使用一般的线段树，每个区间开一个线段树，那么空间复杂度极高，对于稍微大一点的数据便不可行了 主席树恰恰避免了这一点(我觉得它要开的空间也很大…）我们假设每次询问一个区间，都要重新构造一棵线段树，很容易发现，前后两棵线段树，其实是有很多相似的信息的。 经过冷静分析，发现相邻两棵线段树的形状，仅有一条链是不一样的，所以我们可以动态开点，如果对于一个和上一次对应位置相同的节点，我们直接赋相同的信息即可，若是新链的点，新建该节点，再信息更新递归往下，这样子整体的时间复杂度就是 O（nlogn) 实际上主席树的形状并不是一棵严格意义的二叉树，它很像在一棵二叉树外面挂上一条一条新链 关于区间查找： 从上面的分析我们可以发现，对于任意的 i ，我们都建了一棵树 如果我们要查找 [1,i ] 中第 K 大的数，只需要判断左儿子所维护的信息是否大于我们要查找的 K ，大于则向左儿子递归，反之 K 减去这个信息的值再向右儿子递归 由于我们构造的主席树具有可减性，我们要找区间 [ i , j ] 的 K 大数，只需要像查找线段树一样，求出 query（ j ) - query ( i - 1 ) 即可，类似于前缀和的思想 我们来看一下AC代码 AC代码280ms：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define re register int#define rep(i,a,b) for(re i=(a);i&lt;=(b);++(i))using namespace std;const int N=200010;int n,m,le,ri,k,cnt=0;struct node&#123; int l,r,val;&#125;T[N*60];struct num&#123; int val,id; inline bool operator &lt;(const num &amp;rhy) const&#123;return val&lt;rhy.val;&#125;&#125;a[N];int rank[N],root[N];inline void insert(int &amp;num,int &amp;x,int l,int r)&#123; T[++cnt]=T[x];x=cnt;T[x].val++; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(num&lt;=mid) insert(num,T[x].l,l,mid); else insert(num,T[x].r,mid+1,r); &#125;inline int query(int t1,int t2,int l,int r,int k)&#123; if(l==r) return l; int temp=T[T[t2].l].val-T[T[t1].l].val; int mid=(l+r)&gt;&gt;1; if(k&lt;=temp) return query(T[t1].l,T[t2].l,l,mid,k); else return query(T[t1].r,T[t2].r,mid+1,r,k-temp);&#125;int main()&#123; T[0].l=T[0].r=T[0].val=0; scanf("%d%d",&amp;n,&amp;m);root[0]=0; rep(i,1,n) scanf("%d",&amp;a[i].val),a[i].id=i; sort(a+1,a+1+n); rep(i,1,n) rank[a[i].id]=i; rep(i,1,n) root[i]=root[i-1],insert(rank[i],root[i],1,n); while(m--)&#123; scanf("%d%d%d",&amp;le,&amp;ri,&amp;k); printf("%d\n",a[query(root[le-1],root[ri],1,n,k)].val); &#125; return 0;&#125; PS：这只是静态主席树，主席树的入门题，还是很好理解的 整体二分做法浅谈整体二分： 整体二分是二分答案的进化版 设想我们有 Q 个询问，每次询问一个答案，如果我们用一般的二分答案，那么理论上的时间复杂度就是 O ( f( n )* n ),其中 f（n）表示的是做一次询问的时间复杂度，对于 Q 的值很大时，就难以接受了 所以我们不仅二分答案区间 l , r ,还二分询问区间 L ,R 我们用 solve （l , r , L , R ) 表示操作 L ~ R 的数的权值和询问的答案区间为 l , r ,每次二分答案 我们每次求出 mid 对询问的贡献，如果在区间内小于等于 mid 的个数（记为 cnt ）不超过 K ，那么最终的答案也不超过 K ，我们把这一类询问划分到左区间 类似的如果 cnt 大于 K ，我们把它分到右区间，并且 cnt -= K 换句话说，如果这个数贡献小于等于 mid ，我们就不用考虑了 这样划分的层数是 logn ，算上 Q 次询问，再算上算贡献的复杂度，总的时间复杂度就是 O（QlognlogN) ，我们用树状数组维护… 另外整体二分是需要离线操作的，在本题中跑的要比主席树慢…但是空间要比主席树小得多 我们来看一下代码 AC代码730ms123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;cstdio&gt;#include&lt;cstring&gt;#define re register int#define rep(i,a,b) for(re i=(a);i&lt;=(b);++(i))#define INF 0x3f3f3f3fusing namespace std; const int N=500010;int n,m,cnt=0,d,x,y,z;struct question&#123; int l,r,k,id,p;&#125;q[N];int tree[N],ans[N];question q1[N],q2[N];inline int lowbit(int x)&#123;return x&amp;-x;&#125;inline void add(int x,int k)&#123;while(x&lt;=n) tree[x]+=k,x+=lowbit(x);&#125;inline int query(int x)&#123;int res=0;while(x&gt;0) res+=tree[x],x-=lowbit(x);return res;&#125;inline void solve(int L,int R,int l,int r)&#123; if(l&gt;r||L&gt;R) return; if(l==r) &#123;rep(i,L,R) if(q[i].p) ans[q[i].id]=l;return;&#125; int mid=(l+r)&gt;&gt;1,left=0,right=0; rep(i,L,R)&#123; if(q[i].p)&#123; int temp=query(q[i].r)-query(q[i].l-1); if(temp&gt;=q[i].k) q1[++left]=q[i]; else q[i].k-=temp,q2[++right]=q[i]; &#125; else &#123; if(q[i].l&lt;=mid) q1[++left]=q[i],add(q[i].id,q[i].r); else q2[++right]=q[i]; &#125; &#125; rep(i,1,left) if(!q1[i].p) add(q1[i].id,-q1[i].r); rep(i,1,left) q[L+i-1]=q1[i]; rep(i,1,right) q[i+left+L-1]=q2[i]; solve(L,L+left-1,l,mid);solve(L+left,R,mid+1,r);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); rep(i,1,n) &#123; scanf("%d",&amp;d); q[++cnt]=(question)&#123;d,1,0,i,0&#125;; &#125; rep(i,1,m) &#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); q[++cnt]=(question)&#123;x,y,z,i,1&#125;; &#125; solve(1,cnt,-INF,INF); rep(i,1,m) printf("%d\n",ans[i]); return 0;&#125; 后记本人对整体二分的了解并不是很清晰（逃…所以很口糊以后再补吧另外我真菜… 联系qq： 953559040 微博： IncinblePan 洛谷： SherlockPan]]></content>
  </entry>
  <entry>
    <title><![CDATA[Splay 文艺平衡树]]></title>
    <url>%2F2018%2F05%2F15%2Fsplay%2F</url>
    <content type="text"><![CDATA[前言：平衡树是一种很有用的数据结构，在很多高级数据结构中都有很多用处。我们需要熟练掌握 Splay树 虽然它的代码很长很长（一百多行吧… 简述Splay树： Splay是一种数据结构 ( 废话 ），它的每个节点的的左儿子比这个节点小，每个节点的右儿子比这个节点大，跟 treap 差不多，但是实现的时间可能要比 treap 慢。 树的旋转是 splay 的基础，对于一个二叉查找树来说，树的旋转不破坏查找树的结构 Splaying: 简述就是要口糊的，现在我们来看看 Splay Tree 的基本操作Splaying 为了让被查询的条目更接近树根，Splay-Tree 采用的树的旋转操作，同时保证了二叉排序树的性质不变 我们设要旋转的节点为 x ,x 的父亲节点是 p ， p 的父亲节点为 y ,我们在旋转的时候要考虑三种情况： 节点 x 是 p 的左儿子还是右儿子 节点 p 是否为根节点，如果不是的话，可以进行旋转操作 p 为 y 的左儿子还是右儿子 旋转的时候还有三种基本操作： 当 p 为根节点时，若 x 为 p 的左孩子时右旋，反之左旋 当 p 不为根节点时，且 x ，p 同为左儿子或者右儿子时，若同为左儿子，则进行右旋，反之左旋 当 p 不为根节点时，且 x , p 不同为左儿子或者右儿子时，若 p 为左儿子 x 为右儿子，先将 x 左旋再右旋，若 p 为右儿子 x 为左儿子时，先将 x 右旋再左旋 我觉得旋转的操作还是很好写的，列出那么多情况只是方便理解罢了…会了 Splaying ，我觉得 Splay-Tree 已经会了一半了… 还有一件很重要的事 （我终于会挂图片了Makedown真坑…） Splay-Tree 的具体操作：access： access（i）表示我们返回 i 的指针，如果点 i 出现在 Splay-Tree 中，否则我们返回空指针 我们设树根为 root ，从树根向下寻找 若找到含有 i 的节点 x ，就Splaying x ,返回 x 的指针，结束访问操作 如果我们遇到了空指针，代表我们要访问的 i 不在 Splay-Tree 中，我们就只能在树的最后一个非空节点进行一次 Splaying 操作，然后返回空指针 另外，如果这一棵树是空的，我们忽略 Splaying 的操作… join： 我把树的插入和删除操作放在了后面，我们先来看一下合并 join 操作和分裂 split 操作 join 是将树 T1，与 T2 合并，包含两棵树的所有节点，并返回合并后的树 操作先假设 T1 的所有节点都小于 T2，操作结束之后会销毁 T1,T2 我们先访问 T1 中的最大节点 i ，访问结束后，i 就变成了 T1 的根节点，它的右孩子为空。然后我们将 T2 作为 i 的右子树（这时 i 已经成为 T1 的根节点） 并返回完成后的新树，完成操作 split： 我们分裂一棵树并且返回两棵树 T1 和 T2 ，T1 包括所有小于等于 i 的节点，T2 包含所有大于 i 的节点，操作完成后销毁原树 我们先访问（access）i ，然后再根据新节点的左儿子和右儿子的值来进行切断操作，并返回形成的两棵树… insert： 现在我们看看插入和删除的操作 insert（i，T）表示我们将点 i 插入到树 T 中，我们首先执行 split 操作，然后将 T 换成一个包含 i 的根节点的新树，这个根节点的左右两棵子树就是 split 返回的 T1 和 T2 delete： 从树中删除节点 i ，我们首先执行访问（access） i ，然后将 T 变成 i 的左子树和右子树合并 （join） 之后的新树 我觉得在理解合并（join)和分裂（split）操作之后是很容易理解插入（insert）和删除（delete）操作的 另外，在基础操作理解之后，我们来看看更优的插入和删除操作 更优的插入（insert）和删除（delete）： insert：我们先查找 i ，把遇到的空指针替换成一个含有 i 的新节点，再 Splaying 这个由空节点替换后的节点 delete：我们查找含有 i 的节点，设这个节点为 x ，它的父亲节点为 y ,把 x 的左右子树合并之后，再把 y 进行 Splaying 操作 很多东西我也不多做解释了，毕竟手码那么多字也不易，我觉得我写的还是比较容易看懂的。只要认真用心看的话，以上的操作是能够理解的 Splay-Tree的区间操作： 有了以上那么多的操作方法，相信对 Splay-Tree 的理解已经很深了，我们现在只需要学习对 Splay-Tree 的查询操作，就可以运用 Splay-Tree 解题了 区间查询与修改 实际上，Splay-Tree 的中序遍历，即为我们要维护的数列，我们要如何在 Splay-Tree 中表示出某个区间呢 假设我们现在要提取区间 [a,b]，我们先将 a 前面一个数对应的节点旋转到根，将 b 的后面一个数对应的节点转到根的右边，可以发现，这时候根右边的左子树就对应了区间 [a,b]，我们来看一张图… 是不是很好理解？然后我们利用以上的区间操作就可以实现线段树的功能，在这里我们不做多解释，就讲一下区间修改 我们需要用到类似于线段树的延迟标记。对于每一个节点，我们额外记录一个或几个标记，表示以这个节点为根的子树是否进行了某种操作，而且这种操作会影响这个节点的子节点 当我们进行旋转或者别的操作时，我们就下放这些操作，维护该节点的子节点信息，若我们不设置这些延迟标记的话，在进行这些操作的时候就更改子节点的信息，如果这些节点在之后的操作并没有被询问到，那么这次修改的就没有意义了…这也是为什么我们需要延迟标记… Splay-Tree 优于线段树的功能 我们讲两种操作 如果我们要在 a 后面插入一些数，只需要将要插入的树构造成一棵 Splay-Tree ，然后将 a 转到根，并将 a 后面一个数对应的节点转到 a 的右边，最后把新构造的 Splay-Tree 挂到 a 的右节点的左儿子就行了 如果我们要删除区间 [ a , b ] 内的数，只需要提取区间 [ a , b ] ，直接删除即可 讲完了 Splay-Tree 的操作，我们来看一下模板题… Splay-Tree的模板题题目背景这是一道经典的Splay模板题——文艺平衡树。 题目描述您需要写一种数据结构（可参考题目标题），来维护一个有序数列，其中需要提供以下操作：翻转一个区间，例如原有序序列是5 4 3 2 1，翻转区间是[2,4]的话，结果是5 2 3 4 1 输入输出格式输入格式：第一行为n,m n表示初始序列有n个数，这个序列依次是 ( 1 , 2 , ⋯ n−1 , n ) m 表示翻转操作次数 接下来m行每行两个数 [ l , r ][ l , r ] 数据保证 1 ≤ l ≤ r ≤ n 输出格式：输出一行n个数字，表示原始序列经过m次变换后的结果 输入输出样例输入样例#1：5 3 1 3 1 3 1 4 输出样例#1：4 3 2 1 5 说明n,m ≤ 100000 解题分析 说实在话 Splay-Tree上面讲的很多了… 还有我觉得洛谷上 Treap 的模板要比这道题好…几乎纯 Splay-Tree 这道题我们需要对 Splay-Tree 进行区间翻转… 上面好像并没有讲怎么进行区间翻转…没关系自己动手丰衣足食 这里平衡树（老是打Splay-Tree太麻烦了…)维护的不再是权值了，题目中按照编号排序，而最后的结果实际上也是求平衡树的中序排序（性质 所以维护权值肯定不对… 如果我们找的点在树中是第 K 个，那么这个数就是树中的第 K 大，所以序列中的位置就变成了区间第 K 大… 而翻转，其实就是把这个节点的子树左右儿子互换即可，我们只需要一直下放标记，然后把左右儿子交换…最后输出平衡树的中序遍历即可… 这种方法还是比较直白的，我不是很想给出证明…洛谷上很多人也这样写…代码还是比较简单的… AC代码吸氧444ms1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// luogu-judger-enable-o2#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define re register int#define rep(i,a,b) for(re i=(a);i&lt;=(b);++(i))using namespace std;const int N=100010;int n,m,x,y,root=0,tot=0,l,r;struct node&#123; int ch[2],fa,val,tag,son; inline void init(int x,int ff)&#123;fa=ch[0]=ch[1]=0;son=1;val=x;fa=ff;&#125;&#125;a[N];inline void push_up(int x) &#123;a[x].son=a[a[x].ch[0]].son+a[a[x].ch[1]].son+1;&#125;inline void push_down(int x)&#123; if(a[x].tag)&#123; a[a[x].ch[0]].tag^=1; a[a[x].ch[1]].tag^=1; a[x].tag=0; swap(a[x].ch[0],a[x].ch[1]); &#125;&#125;inline void rotate(int x)&#123; re y=a[x].fa; re z=a[y].fa; re k=a[y].ch[1]==x; a[z].ch[a[z].ch[1]==y]=x; a[x].fa=z; a[y].ch[k]=a[x].ch[k^1]; a[a[x].ch[k^1]].fa=y; a[x].ch[k^1]=y; a[y].fa=x; push_up(y);push_up(x);&#125;inline void splay(int x,int goal)&#123; while(a[x].fa!=goal)&#123; re y=a[x].fa; re z=a[y].fa; if(z!=goal) (a[z].ch[1]==x)^(a[y].ch[1]==y)?rotate(x):rotate(y); rotate(x); &#125; if(goal==0) root=x;&#125;inline void insert(int x)&#123; int u=root,ff=0; while(u)&#123; ff=u;u=a[u].ch[x&gt;a[u].val]; &#125; u=++tot; if(ff) a[ff].ch[x&gt;a[ff].val]=u; a[u].init(x,ff); splay(u,0);&#125; inline int K_th(int x)&#123; int u=root; while(1)&#123; push_down(u); if(a[a[u].ch[0]].son&gt;=x) u=a[u].ch[0]; else if(a[a[u].ch[0]].son==x-1) return u; else x-=a[a[u].ch[0]].son+1,u=a[u].ch[1]; &#125;&#125;inline void solve(int x)&#123; push_down(x); if(a[x].ch[0]) solve(a[x].ch[0]); if(a[x].val&gt;1&amp;&amp;a[x].val&lt;n+2) printf("%d ",a[x].val-1); if(a[x].ch[1]) solve(a[x].ch[1]);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); rep(i,1,n+2) insert(i); while(m--)&#123; scanf("%d%d",&amp;x,&amp;y); l=K_th(x);r=K_th(y+2); splay(l,0); splay(r,l); a[a[a[root].ch[1]].ch[0]].tag^=1; &#125; solve(root); printf("\n"); return 0;&#125; 其实一些解释在上面已经给出了，我也不在代码里加注释了 我觉得还是比较能理解的… 后记 其实我还是想加一道纯平衡树的题的（起码不用想怎么翻转… 有时候练练模板还是好的但是我觉得这篇的篇幅已经很长了… 那就这样吧我觉得很详细了… 还有一件事我好菜啊… 欢迎指正联系方式如下 联系qq： 953559040 微博： IncinblePan 洛谷： SherlockPan]]></content>
  </entry>
  <entry>
    <title><![CDATA[左偏树]]></title>
    <url>%2F2018%2F05%2F14%2F%E5%B7%A6%E5%81%8F%E6%A0%91%2F</url>
    <content type="text"><![CDATA[前言：前几天学习高级数据结构，现在准备复习… 左偏树杂谈： 左偏树是一种可并堆。 对于一般的而言，我们可以很容易地想到一种时间复杂度为 O（n ) 的算法合并两个堆。看样子可以接受，但是如果要合并一万次，十万次的话，总的时间复杂度却很难让人接受，因此左偏树应运而生。 优先队列也能算是可并堆，在优先队列中插入一个数，时间复杂度应该是 O（log2n) （百度上说的本人没有证明） ，但是优先队列不支持合并。 而左偏树，是一种可并堆的实现，能够在时间复杂度为 O（loga + logb) 的情况下合并两个堆。 现在我们着重讲讲左偏树的性质与合并时的算法 左偏树性质： 左偏树是一棵二叉树，它具有二叉树的性质 比如说一个节点的键值小于等于它两个儿子的键值，因而这棵树的根一定是整个堆中最小的数，我们可以在 O（1）的时间复杂度下取出最小值 它的节点有一个左指针和一个右指针，还有这个节点的键值，还有距离。键值很好理解，而左偏树的重点是它的距离，合并删除的实现也和距离分不开，也因距离而得名为左偏树（口糊）我们这样定义距离：（划重点！！！ 如果一个节点，它的左儿子或者右儿子为空，那么我们称这个节点为外节点，换句话说，称为外节点的点的儿子只有一个或者没有（真可伶 而左偏树的精髓–距离，指的是该节点 i 到它最近的外节点所经过的边数。如果这个点为外界点，那么这个点的距离为 0，如果这个点为空，那么这个点的距离为 -1 。 我们称一棵左偏树的距离为这棵树根节点的距离。 左偏性质： 左偏性质导致该数据类型叫做左偏树。 即该节点左孩子的距离要不小于右孩子的距离 我们可以得到，节点 i 的距离等于它右儿子的距离加 1 ，所以我们规定外节点的距离为0空节点距离为 -1 而在进行合并和删除可并堆的时候，我们一定要注意维护左偏性质 距离与节点的关系 一棵左偏树的距离为 k ，那么这棵左偏树的节点数最少有 2k+1-1（我觉得用极端法就可以证明 还有一点我不会证明的（我也没去证明…）若左偏树的距离为一定值，则节点数最少的左偏树是完全二叉树。 一棵 N 个节点左偏树距离最多为 log（N+1）-1. 我也想要插入图片！！！ 左偏树模板:题目描述如题，一开始有N个小根堆，每个堆包含且仅包含一个数。接下来需要支持两种操作： 操作1： 1 x y 将第x个数和第y个数所在的小根堆合并（若第x或第y个数已经被删除或第x和第y个数在用一个堆内，则无视此操作） 操作2： 2 x 输出第x个数所在的堆最小数，并将其删除（若第x个数已经被删除，则输出-1并无视删除操作） 输入输出格式输入格式：第一行包含两个正整数N、M，分别表示一开始小根堆的个数和接下来操作的个数。 第二行包含N个正整数，其中第i个正整数表示第i个小根堆初始时包含且仅包含的数。 接下来M行每行2个或3个正整数，表示一条操作，格式如下： 操作1 ： 1 x y 操作2 ： 2 x 输出格式：输出包含若干行整数，分别依次对应每一个操作2所得的结果。 输入输出样例:输入样例#1： 5 5 1 5 4 2 3 1 1 5 1 2 5 2 2 1 4 2 2 2 输出样例#1： 1 2 我觉得我们对左偏树一些基本性质的讲解已经很清楚了，我们现在来看一下怎么实现代码… 初始化节点每个节点有四个元素：左儿子右儿子键值距离 我们用并查集来找这一个堆的祖宗…注意**不 能路径压缩**因为如果这个堆的祖先被删去了，对于这个堆你就找不到祖先了（大哭 现在讲讲合并操作（我觉得我应该找个图来的 如果一棵树为空，那么我们只需要返回另一棵树，像这样 1if(!x||!y) return x+y; 如果两棵树为非空，我们假设 A 的根节点小于等于 B 的根节点（否则交换 A ， B 把 A 的根节点作为新树 C 的根节点，再合并 A 的右子树和 B 合并 A 的右子树和 B 后，A 的右子树的距离可能会变大，当合并后 A 的右儿子距离大于左儿子距离时，我们只需要交换左儿子和右儿子即满足了左偏树的性质 最后，我们更新 A 的距离，即 dis( A )=dis( right(A) )+1; 不难发现，合并后新的树也满足左偏性质 我们贴一下代码 12345678910 inline int merge(int x,int y)&#123; if(!x||!y) return x+y; if(a[x].value&gt;a[y].value||(a[x].value==a[y].value&amp;&amp;x&gt;y)) swap(x,y); int &amp;ls=a[x].l,&amp;rs=a[x].r; rs=merge(rs,y); a[rs].fa=x; if(a[rs].dis&gt;a[ls].dis) swap(ls,rs); a[x].dis=a[rs].dis+1; return x;&#125; 合并操作之后我们再讲讲删除节点 其实删除操作很简单，如果我们要删除节点为 X ，只需要把 X 节点的信息清空，再把 X 的左儿子和右儿子进行合并即可。 我们贴一下代码 inline void del(int x){ int ls=a[x].l,rs=a[x].r; a[x].value=-1; a[ls].fa=a[rs].fa=0; merge(ls,rs); } 这样我们讲完了左偏树的基本操作，现在贴出这道模板题的AC代码 AC代码氧气优化152ms1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// luogu-judger-enable-o2#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define re register int#define rep(i,a,b) for(re i=(a);i&lt;=(b);++(i))using namespace std;const int N=100010;int n,m;int x,y;struct node&#123; int l,r,value,fa,dis;&#125;a[N];//inline void swap(int &amp;a,int &amp;b) &#123;a^=b^=a^=b;&#125;inline int find(int x)&#123;return a[x].fa?find(a[x].fa):x;&#125;inline int merge(int x,int y)&#123; if(!x||!y) return x+y; if(a[x].value&gt;a[y].value||(a[x].value==a[y].value&amp;&amp;x&gt;y)) swap(x,y); int &amp;ls=a[x].l,&amp;rs=a[x].r; rs=merge(rs,y); a[rs].fa=x; if(a[rs].dis&gt;a[ls].dis) swap(ls,rs); a[x].dis=a[rs].dis+1; return x;&#125;inline void del(int x)&#123; int ls=a[x].l,rs=a[x].r; a[x].value=-1; a[ls].fa=a[rs].fa=0; merge(ls,rs);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); a[0].dis=-1; rep(i,1,n) scanf("%d",&amp;a[i].value); while(m--)&#123; int type; scanf("%d",&amp;type); switch(type)&#123; case 1:&#123; scanf("%d%d",&amp;x,&amp;y); if(a[x].value!=-1&amp;&amp;a[y].value!=-1)&#123; int p=find(x),q=find(y); if(p!=q) merge(p,q); &#125; break; &#125; case 2:&#123; scanf("%d",&amp;x); if(a[x].value==-1) printf("-1\n"); else &#123; int p=find(x); printf("%d\n",a[p].value); del(p); break; &#125; &#125; &#125; &#125; return 0;&#125; 我觉得我讲的已经很详细了，现在我们来进行实战 Monkey King：题目描述：一开始有n只孤独的猴子，然后他们要打m次架，每次打架呢，都会拉出自己朋友最牛叉的出来跟别人打，打完之后他的朋友的战斗力就会减半，每次打完架双方所有人就会成为朋友（正所谓不打不相识o(∩_∩)o ）。问每次打完架之后那俩猴子最牛叉的朋友战斗力还有多少，若朋友打架就输出-1. 输入输出格式：暂不支持英文翻译…. 解题分析： 很容易发现这道题需要我们合并两个堆… 但是每个堆合并之后的根的键值会变化… 我们使用大根堆，以便找到堆中最大的数来打架…然后考虑左偏树… 合并的操作上面的模板题我们已经探讨过了，但是每个合并之前的左偏树的根该如何维护其性质呢 合并之后的两个堆的根不一定是原先两个堆的根中的一个（因为战斗力会下降… 所以我们应该把要合并的两堆的根先删去，键值除以二，得到合并后的键值，再插入(即合并只有一个数的堆和删去根后的堆），再合并两个经过操作的堆，这时候的根节点即两堆猴子打完架后战斗力最强的猴子… 这样我们只需要合并操作与删除操作，再注意一些细节，就容易就过了… 目前也只找到一道用左偏树写的题… 贴出代码… AC代码氧气优化176ms12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// luogu-judger-enable-o2#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define re register int#define rep(i,a,b) for(re i=(a);i&lt;=(b);++(i))#define max(a,b) (a&gt;b?a:b)using namespace std;int n,m,x,y;struct node&#123; int l,r,dis,value,fa;&#125;a[100010];inline int find(int x)&#123;return a[x].fa!=x?find(a[x].fa):x;&#125;inline int merge(int x,int y)&#123; if(!x||!y) return x+y; if(a[x].value&lt;a[y].value) swap(x,y); a[x].r=merge(a[x].r,y); a[a[x].r].fa=x; if(a[a[x].l].dis&lt;a[a[x].r].dis) swap(a[x].r,a[x].l); if(!a[x].r)a[x].dis=0; else a[x].dis=a[a[x].r].dis+1; return x;&#125;inline int del(int x)&#123; int ls=a[x].l,rs=a[x].r; a[x].l=a[x].r=a[x].dis=0;a[ls].fa=ls;a[rs].fa=rs; return merge(ls,rs);&#125;int main()&#123; while(scanf("%d",&amp;n)!=EOF)&#123; a[0].dis=-1; rep(i,1,n) &#123; scanf("%d",&amp;a[i].value); a[i].fa=i; a[i].dis=a[i].r=a[i].l=0; &#125; scanf("%d",&amp;m); rep(i,1,m)&#123; scanf("%d%d",&amp;x,&amp;y); int p=find(x),q=find(y); if(p==q) &#123; printf("-1\n");continue; &#125; a[p].value/=2;a[q].value/=2; int lr=del(p),rr=del(q); lr=merge(lr,p);rr=merge(rr,q); lr=merge(lr,rr); printf("%d\n",a[lr].value); &#125; &#125; return 0;&#125; 本文完，欢迎指正…（我太弱了… 联系qq： 953559040 微博： IncinblePan 洛谷： SherlockPan]]></content>
  </entry>
  <entry>
    <title><![CDATA[SDOI2009 HH的项链]]></title>
    <url>%2F2018%2F05%2F13%2FSDoi2009%2F</url>
    <content type="text"><![CDATA[暴力 莫队 树状数组本蒟蒻的第一篇博客对博客的格式还不是很熟悉…我们回到正题，现在先来看一下题面 题目描述HH 有一串由各种漂亮的贝壳组成的项链。HH 相信不同的贝壳会带来好运，所以每次散步完后，他都会随意取出一段贝壳，思考它们所表达的含义。HH 不断地收集新的贝壳，因此，他的项链变得越来越长。有一天，他突然提出了一个问题：某一段贝壳中，包含了多少种不同的贝壳？这个问题很难回答……因为项链实在是太长了。于是，他只好求助睿智的你，来解决这个问题。 输入输出格式输入格式：第一行：一个整数N，表示项链的长度。 第二行：N 个整数，表示依次表示项链中贝壳的编号（编号为0 到1000000 之间的整数）。 第三行：一个整数M，表示HH 询问的个数。 接下来M 行：每行两个整数，L 和R（1 ≤ L ≤ R ≤ N），表示询问的区间。 输出格式：M 行，每行一个整数，依次表示询问对应的答案。 解题分析暴力 初看题目，打暴力肯定是会T的（废话），初步估计40分… 暴力枚举询问的空间，每次清空用于记忆的数组… 莫队 80分 看到这道题其实很容易想到是莫队的… 莫队是基于分块思想的一种算法，很好理解… 我们先把询问离线，之后再排个序… 对于区间 l ~ r ,如果我们已知在这个区间里不同的贝壳种类有sum个，那么对于区间 l ~ r+1,或者区间 l-1 ~ r 就可以在O（1）的时间复杂度下得出对于 l-1 ~ r 的sum的值 所以我们把询问的区间排个序，使 l 和 r 尽可能少的移动，就可以比暴力少算很多次，这一段很好理解吧 但是考虑最不优的询问，如果询问的区间一个在数列的最左边，一个最右边，这样进行 l 和 r 的转移，时间复杂度就是要O（n)，还不如写暴力 因此我们用上分块的思想，把这一串数列分成 sqrt( n ) 块，这样时间复杂度就会降低很多。（分块不懂？！那你还学莫队！！） 实际上莫队是一种近似暴力的方法，时间复杂度比暴力客观得多，但是很不巧这道题的数据很强莫队卡不过去只有80分… 贴出莫队代码氧气优化80分 12345678910111213141516171819202122232425262728293031323334353637383940// luogu-judger-enable-o2#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#define re register int#define rep(i,a,b) for(re i=(a);i&lt;=(b);++(i))using namespace std;const int N=500010;int n,m,le=1,ri=1;int a[N],clo[2*N],sum=1,size,ans[N],belong[N];struct que&#123; int l,r,id; inline bool operator &lt;(const que &amp;rhy) const&#123;return belong[l]==belong[rhy.l]?r&lt;rhy.r:belong[l]&lt;belong[rhy.l];&#125;&#125;q[N]; inline void move(int x,int opt)&#123; clo[a[x]]+=opt; if(clo[a[x]]==0&amp;&amp;opt==-1) sum--; if(clo[a[x]]==1&amp;&amp;opt==1) sum++;&#125;int main()&#123; scanf("%d",&amp;n);size=sqrt(n); rep(i,1,n) scanf("%d",&amp;a[i]);rep(i,1,n) belong[i]=(i-1)/size+1; scanf("%d",&amp;m); rep(i,1,m)scanf("%d%d",&amp;q[i].l,&amp;q[i].r),q[i].id=i; sort(q+1,q+1+m);clo[a[1]]++; rep(i,1,m)&#123; while(le&lt;q[i].l)&#123;move(le,-1);le++;&#125; while(le&gt;q[i].l)&#123;le--;move(le,1);&#125; while(ri&gt;q[i].r)&#123;move(ri,-1);ri--;&#125; while(ri&lt;q[i].r)&#123;ri++;move(ri,1);&#125; ans[q[i].id]=sum; &#125; rep(i,1,m) printf("%d\n",ans[i]); return 0;&#125; -不熟悉Makedown的我觉得这样应该勉强能看排版丑勿介 正解树状数组 100分 我觉得其实很容易就会想到用树状数组或者线段树，但是我好像并不会维护所以才去打的莫队…莫队加了优化也是可以过的可是我不会（逃 如果知道怎么去维护树状数组其实题目就已经完成了（废话） 我们来看一组数列 1 3 4 2 1 ，我们可以发现，对于询问区间 r = 5 的所有询问中（ l &lt;= r ), 因为这个数列的第五个为 1 ，而第一个也是 1 ，所以对于 r = 5 而言，第一个数是没有多大意义的… 我觉得很好理解…所以我们可以对所有询问离线，再对 r 进行排序，用树状数组维护 （好像也不需要维护），只需要对于每次询问求前缀和即可 单点增加与查找的函数都是模板没有什么变化，我们只需要想到如何用树状数组表示出前 i 个贝壳颜色的种类 我们用 last 数组表示出该颜色在此之前第一次出现的位置， vis 数组用于表示 i 颜色是否出现过 很容易得出 query（r)-query(l-1)即为答案但是如何不出错呢，我们要这样动态更新呢 只要在左端点之前出现过，就加上，想通这一点，只需要最基础的树状数组就行了 洛谷吸氧 424 ms AC100分 12345678910111213141516171819202122232425262728293031323334353637383940// luogu-judger-enable-o2#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define re register int#define rep(i,a,b) for(re i=(a);i&lt;=(b);++(i))using namespace std;const int N=1000010;int n,m;int v[N],tree[N],ans[N],vis[N],last[N];struct question&#123; int l,r,id; inline bool operator &lt; (const question &amp;rhy)const &#123;return r!=rhy.r?r&lt;rhy.r:l&lt;rhy.l;&#125;&#125;q[500010];inline int lowbit(int x)&#123;return x&amp;-x;&#125;inline void add(int x,int k)&#123;while(x&lt;=n) tree[x]+=k,x+=lowbit(x);&#125;inline int query(int x)&#123;int ans=0;while(x&gt;0)&#123;ans+=tree[x];x-=lowbit(x);&#125;return ans;&#125;int main()&#123; scanf("%d",&amp;n); rep(i,1,n) scanf("%d",&amp;v[i]);scanf("%d",&amp;m); rep(i,1,m) &#123;scanf("%d%d",&amp;q[i].l,&amp;q[i].r);q[i].id=i;&#125; sort(q+1,q+1+m); int now=0; rep(i,1,m)&#123; while(now&lt;q[i].r) &#123; now++; if(!vis[v[now]]) vis[v[now]]=1,last[v[now]]=now,add(now,1); else add(last[v[now]],-1),add(now,1),last[v[now]]=now; &#125; ans[q[i].id]=query(q[i].r)-query(q[i].l-1); &#125; rep(i,1,m) printf("%d\n",ans[i]); return 0;&#125; 感谢资瓷欢迎围观指正 联系qq： 953559040 微博： IncinblePan 洛谷： SherlockPan]]></content>
  </entry>
  <entry>
    <title><![CDATA[前言]]></title>
    <url>%2F2018%2F05%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[多亏了吴宜修这个巨（zhi）爷(zhang)给了我超低版本号的node.js，导致我的博客计划延期了一个多月所以晚上*吴宜修？！我觉得很星]]></content>
  </entry>
</search>
